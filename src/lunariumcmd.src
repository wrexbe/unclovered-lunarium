// converted colors
// # 8 2 5 4 d 1 -> # E 6 E 6 F A
// # 7 1 4 1 c 4 -> # C C C C F F


cmds={}
helplist={}

//defaults
helplist.defaults="-=Defaults=-"

helplist.help={"params": "[command]", "usage": "List all commands, or list command usage!"}
helplist.addal={"params": "[key][value]", "usage": "Add alias"}
helplist.delal={"params": "[key]", "usage": "Delete alias"}
// helplist.fs={"params": "[FoxScriptCode]", "usage": "Invoke the FoxScript code terminal"}
helplist.exit={"params": "N/A", "usage": "Go back a shell, or exit Lunarium"}
helplist.clear={"params": "N/A", "usage": "Clears the screen"}
helplist["while"]={"params": "[quantity][command][args]", "usage": "Repeat a command"}
// helplist.setup={"params": "[-m/-rs/-ps]", "usage": "Setup Lunarium"}
helplist.anon={"params": "N/A", "usage": "Enable or disable hidden mode"}
// helplist.sshs={"params": "[-c]", "usage": "Displays SSH virus logs, or clears them"}
// helplist.passwds={"params": "[-c]", "usage": "Displays passwd virus logs, or clears them"}
helplist.disclaimer = {"params": "N/A", "usage": "Licensing details"}
// helplist.mailbomb={"params": "[recipient][subject][body][quantity]", "usage": "Spams an email's inbox"}
// helplist.clrmail={"params": "N/A", "usage": "Clears emails"}
// helplist.readmail={"params": "N/A", "usage": "Read emails"}

//text controls
helplist.text="-=Text=-"

helplist.vim={"params": "[file][text]", "usage": "Text editor"}
helplist.cat={"params": "[path]", "usage": "Get the contents of a file"}
helplist.pwd={"params": "N/A", "usage": "Outputs current directory"}
helplist.whoami={"params": "N/A", "usage": "Outputs current user"}
helplist.whereami={"params": "N/A", "usage": "Outputs current public IP address"}
helplist.echo={"params": "[string]", "usage": "Echos input as joined output"}
helplist.grep={"params": "[searchTerm][string]", "usage": "Finds the line containing the search term"}
helplist.crack={"params": "[hash]", "usage": "Crack a password hash"}
helplist.grab={"params": "[a/p/b/m]", "usage": "Crack all(default)/only passwd/only banks/only mails"}
helplist.encrypt={"params": "[string][key][enc/dec]", "usage": "Encrypt or decrypt messages"}
helplist.compress={"params": "[enc/dec][string]", "usage": "Compress or decompress messages"}
helplist.md5={"params": "[string]", "usage": "Hashes a string using MD5"}
helplist.S256={"params": "[string]", "usage": "Hashes a string using Sha256"}
helplist.rot={"params": "[pos][string]", "usage": "Encrypts a string using ROT"}
helplist.vigenere={"params": "[string][key][enc/dec]", "usage": "Encrypts a string using the Vigenere cipher"}
helplist.base={"params": "[number][orad][irad]", "usage": "Changes the base of numbers"}

//file controls
helplist.files="-=Files=-"

helplist.ls={"params": "[path]", "usage": "Lists files"}
helplist.tree={"params": "N/A", "usage": "Lists the entire file system along with file vulnerabilities"}
helplist.cd={"params": "[path]", "usage": "Changes working directory"}
helplist.mv={"params": "[file][newPath]", "usage": "Moves files"}
helplist.cp={"params": "[file][newPath]", "usage": "Copies files"}
helplist.mkdir={"params": "[path]", "usage": "Creates a folder"}
helplist.touch={"params": "[path]", "usage": "Create a text file"}
helplist.build={"params": "[src][path]", "usage": "Builds a source file"}
helplist.shrink={"params": "[src][size]", "usage": "Shrinks source files"}
helplist.rm={"params": "[file]", "usage": "Deletes files"}
helplist.chmod={"params": "[file][perms][-r]", "usage": "Changes the permission levels of a file"}
helplist.chown={"params": "[file][owner][-r]", "usage": "Changes the owner of a file"}
helplist.chgrp={"params": "[file][group][-r]", "usage": "Changes the group of a file"}

//device controls
helplist.devices="-=Devices=-"

helplist.passwd={"params": "[user][password]", "usage": "Change users password"}
helplist.bash={"params": "[file][params]", "usage": "Runs a CLI program"}
helplist.ps={"params": "N/A", "usage": "Lists processes"}
helplist.monitor={"params":"[(opt)secs]", "usage": "Autoupdate ps"}
helplist.bios={"params": "N/A", "usage": "Perform a full system analysis"}
helplist.kill={"params": "[PID/all]", "usage": "Terminates a running process"}
helplist.sudo={"params": "[user][password]", "usage": "Switch account"}
helplist.useradd={"params": "[user][password]", "usage": "Adds a new user"}
helplist.userdel={"params": "[user]", "usage": "Deletes a user"}
helplist.groups={"params": "[user]", "usage": "List users groups"}
helplist.groupadd={"params": "[user][group]", "usage": "Adds user to group"}
helplist.groupdel={"params": "[user][group]", "usage": "Removes user from group"}
helplist.sessions={"params": "N/A", "usage": "Open a different session!"}
helplist.set={"params": "[variable][content]", "usage": "Change a variable in case it is set incorrectly"}

//network controls
helplist.network="-=Network=-"

helplist.ssh={"params": "[user][password][ip][port]", "usage": "Connect to a server"}
helplist.nmap={"params": "N/A", "usage": "Maps out the selected RHost"}
helplist.smtp = {"params": "[port]", "usage": "Shows all registered users via smtp"}
helplist.shell={"params": "[-y/-s]", "usage": "Starts a terminal on the connected system"}
helplist.shells={"params": "N/A", "usage": "Open a different shell!"}
helplist.apt={"params": "[update/upgrade/search/show/add/del/install][args]", "usage": "apt-get service"}
helplist.rootkit={"params": "[-s]", "usage": "Uploads root attack kit"}
helplist.put={"params": "[file][path]", "usage": "Uploads a file"}
helplist.get={"params": "[file][path]", "usage": "Downloads a file"}
helplist.rhost={"params": "[ip]", "usage": "Selects an IP for attacks"}
helplist.random={"params": "N/A", "usage": "Generates a random IP and sets it at the RHost"}
helplist.ping={"params": "[ip]", "usage": "Test connection to IP"}
helplist.target={"params": "[port][args]", "usage": "Performs an attack on the selected RHost"}
helplist.escalate={"params": "[args]", "usage": "Escalate access using local libraries"}
helplist.results={"params": "[-c]", "usage": "Shows results from target/escalate, or clears them"}
// helplist.exploits={"params": "[-c]", "usage": "Shows every vulnerability saved, or clears them"}
helplist.use={"params": "[exp]", "usage": "Use an exploit from the results list"}
// helplist.rss={"params": "N/A", "usage": "Remote reverse shell server connector"}
helplist.rsi={"params": "N/A", "usage": "Reverse shell interface"}
helplist.sniffer={"params": "[-y]", "usage": "Sniffs connections"}
helplist.net = {"params": "N/A", "usage": "Shows networks around you"}
helplist.iwctl = {"params": "[bssid][essid][password]", "usage": "Connects you to a wifi"}
helplist.lan = {"params": "[ip][gateway]", "usage": "Connects you to ethernet"}
helplist.inet={"params": "[bssid][essid]", "usage": "Hacks wifi connections"}
helplist.dictssh={"params": "[ip][port][user]", "usage": "Bruteforces an SSH connection"}
helplist.brutessh={"params": "[ip][port][user]", "usage": "Bruteforces an SSH connecting using Base 62 counting"}
helplist.dictsudo={"params": "[user]", "usage": "Bruteforces user password"}
helplist.brutesudo={"params": "[user]", "usage": "Bruteforces user password using Base 62 counting"}
helplist.mailbomb={"params": "[recipient][subject][body][quantity]", "usage": "Spams an email's inbox"}
helplist.clrmail={"params": "N/A", "usage": "Clears emails"}
helplist.readmail={"params": "N/A", "usage": "Read emails"}

//server control
// helplist.revoke={"params": "N/A", "usage": "Revokes fingerprint access token"} // entirely deprecated feature. Previously used in the passwords-based 2FA era of Lunar. Now replaced with the automated email sign in. -Clover

//destructive controls
helplist.destructive="-=Destructive=-"

helplist.brick={"params": "N/A", "usage": "Deletes all files in /"}
helplist.dos={"params": "N/A", "usage": "Local Denial Of Service attack"}
helplist.rdos={"params": "[quantity]", "usage": "Memory Denial Of Service attack"}
helplist.fdos={"params": "[quantity][name]", "usage": "Storage Denial Of Service attack"}
helplist.cdos={"params": "[quantity]", "usage": "CPU Denial Of Service attack"}

//virus controls
helplist.virus="-=Viruses=-"

// helplist.infect={"params": "N/A", "usage": "Infects /bin/ssh, /bin/passwd, and /bin/ps"}
helplist.rshell={"params": "[ip][process][port]", "usage": "Creates a reverse shell connection"}
// helplist.ransom={"params": "N/A", "usage": "Encrypt a system and demand payment for decryption"}
// helplist.inject={"params": "[file]", "usage": "Inject reverse shell code into a source code file"}
// helplist.aptjack={"params": "N/A", "usage": "Jack the apt stream and infect every file!"}

//security controls
helplist.security="-=Security=-"

helplist.fyrwall={"params": "N/A", "usage": "SOLSTICE Fyrwall Security Analysis System"}
helplist.secure={"params": "[-s/-h]", "usage": "Secures your server or home computer"}
helplist.corrupt={"params": "N/A", "usage": "Corrupts /var/system.log, covers disconnect tracks"}
helplist.libcheck = {"params": "[path]", "usage": "Shows you the information about library"}

//clipboard control
helplist.clipboard="-=Clipboard=-"
helplist.copy={"params": "[name][string]", "usage": "Copies text to the clipboard"}
helplist.ccopy={"params": "N/A", "usage": "Clears the clipboard"}


cmds.help=function(sin)
    out={}
    out.bool=2
    if sin.len then
    	if helplist.hasIndex(sin[0]) then
    		print("<color=#CCCCFF>"+sin[0]+"</color>")
    		print("<color=#E6E6FA>"+helplist[sin[0]].params+"</color>")
    		print("<color=#E6E6FA>"+helplist[sin[0]].usage+"</color>")
    	end if
    	return out
    end if
    output=[]
    l=["<color=#CCCCFF>Command","Usage</color>"]
    output.push(l.join(" "))
    for i in helplist.indexes
    	if typeof(helplist[i]) == "string" then
    		output.push("\n<color=#CCCCFF>"+helplist[i]+"</color>\n")
    	else
    		l=["<color=#CCCCFF>"+i+"</color>","<color=#E6E6FA>"+helplist[i].params+"</color>"]
    		output.push(l.join(" "))
    	end if
    end for
    print(format_columns(output.join("\n")))
    return out
end function

cmds.exit=function(sin)
    out={}
    out.bool=2
    if not origShell then
    	if globals.sessions[session].shells.len == 0 then
			globals.sessions.remove(session)
    		globals.session=0
    		print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Session reverted to 0</color>")
    		xshell=globals.sessions[session].shell
			globals.session=0
    		globals.origShell=xshell.orig
    		globals.shell=xshell.shell
    		globals.xuser=xshell.user
    		globals.xpath=xshell.path
    	else
    		xshell=globals.sessions[session].shells.pop
			globals.sessions[session].shell=xshell
    		globals.origShell=xshell.orig
    		globals.shell=xshell.shell
    		globals.xuser=xshell.user
    		globals.xpath=xshell.path
    	end if
    else
    	exit("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Closing Lunarium, come back soon!</color>")
    end if
    return out
end function

cmds.clear=function(sin)
    out={}
    out.bool=2
    clear_screen
    return out
end function

cmds.crack=function(sin)
    out={}
    out.bool=1
    if sin.len != 1 then return error("Invalid parameters", "crack")
    if server.shell then out.out=decipher(server.cp,sin[0]) else out.out=decipher(cp,sin[0])
	if not out.out then out.bool=3
    return out
end function

// cmds.setup=function(sin)
//     out={}
//     out.bool=2
//     if not server.shell then
//     	out.bool=3
//     	return out
//     end if
//     if sin.len > 1 then return error("Invalid parameters")
//     if anon and sin.len == 0 then return error("Hidden mode activated")
//     if sin.len == 0 then
//     	print("<color=#CCCCFF>Mail: </color><color=#E6E6FA>"+conf.mail.user+" "+conf.mail.pass+"</color>")
//     	print("<color=#CCCCFF>Server: </color><color=#E6E6FA>"+conf.rss.ip+" "+conf.rss.user+"@"+conf.rss.pass+" "+conf.rss.port+" / "+conf.rss.rport+"</color>")
//     	print("<color=#CCCCFF>Process: </color><color=#E6E6FA>"+conf.proc+"</color>")
//     	return out
//     end if
//     if sin[0] == "-m" then
//     	newmail=user_input("<color=#CCCCFF>[Email]$ </color><color=#E6E6FA>",anon)
//     	newepass=user_input("<color=#CCCCFF>[Pass]$ </color><color=#E6E6FA>",anon)
//     	test=mail_login(newmail,newepass)
//     	if typeof(test) == "string" then return error(test)
//     	conf.mail.user=newmail
// 		conf.mail.pass=newepass
//     	xconf.set_content(encrypt(str(conf),"Lunarium","enc"))
//     	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Email updated successfully</color>")
//     else if sin[0] == "-rs" then
//     	newserver=user_input("<color=#CCCCFF>[Server]$ </color><color=#E6E6FA>",anon)
//     	newuser=user_input("<color=#CCCCFF>[User]$ </color><color=#E6E6FA>",anon)
//     	newpass=user_input("<color=#CCCCFF>[Pass]$ </color><color=#E6E6FA>",anon)
//     	newport=user_input("<color=#CCCCFF>[Port]$ </color><color=#E6E6FA>").to_int
//     	if typeof(newport) != "number" then return error("Invalid port")
//     	newrport=user_input("<color=#CCCCFF>[RPort]$ </color><color=#E6E6FA>").to_int
//     	if typeof(newrport) != "number" then return error("Invalid port")
// 		conf.rss.ip=newserver
// 		conf.rss.user=newuser
// 		conf.rss.pass=newpass
// 		conf.rss.port=newport
// 		conf.rss.rport=newrport
//     	xconf.set_content(encrypt(str(conf),"Lunarium","enc"))
//     	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>RShell Server updated successfully</color>")
//     else if sin[0] == "-ps" then
//     	newproc=user_input("<color=#CCCCFF>[Name]$ </color><color=#E6E6FA>")
//     	conf.proc=newproc
// 		xconf.set_content(encrypt(str(conf),"Lunarium","enc"))
//     	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>RShell Process name updated successfully</color>")
//     end if
//     return out
// end function

// cmds.sshs=function(sin)
//     out={}
//     out.bool=2
//     logs="/root/sshs"
// 	if not server.shell then
//     	out.bool=3
//     	return out
//     end if
//     sshs=server.shell.host_computer.File(logs)
//     if not sshs then return error("Could not obtain logs")
//     if sin.len == 1 and sin[0] == "-c" then
//     	sshs.set_content("<0%O<0w")
//     	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Cleared connection logs</color>")
//     	return out
//     end if
//     cont=sshs.get_content
//     if cont.len <= 7 then return error("No logs found")
// 	cont=deserialize(encrypt(cont,"Lunarium","dec"))
//     plog=[["<color=#CCCCFF><b>SOURCE","DEST","PORT","USER","PASS</b></color>"].join(" ")]

//     for log in cont
//     	plog.push(["<color=#CCCCFF>"+log.source,log.dest,log.port,log.user,log.pass+"</color>"].join(" "))
//     end for
//     print(format_columns(plog.join("\n")))
//     return out
// end function

// cmds.passwds=function(sin)
//     out={}
//     out.bool=2
//     logs="/root/passwd"
// 	if not server.shell then
//     	out.bool=3
//     	return out
//     end if
//     sudos=server.shell.host_computer.File(logs)
//     if not sudos then return error("Could not obtain logs")
//     if sin.len == 1 and sin[0] == "-c" then
// 	    sudos.set_content("<0%O<0w")
// 	    print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Cleared passwd logs</color>")
// 	    return out
//     end if
//     cont=sudos.get_content
//     if cont.len <= 7 then return error("No logs found")
// 	cont=deserialize(encrypt(cont,"Lunarium","dec"))
//     plog=[["<color=#CCCCFF><b>SOURCE","USER","PASS</b></color>"].join(" ")]

//     for log in cont
// 	    plog.push(["<color=#CCCCFF>"+log.source,log.user,log.pass+"</color>"].join(" "))
//     end for
//     print(format_columns(plog.join("\n")))
//     return out
// end function

cmds.clrmail=function(sin)
    out={}
    out.bool=2
    if not server.shell then
        umaila=user_input("<color=#CCCCFF>[Email]$ </color><color=#E6E6FA>",anon)
        umaill=user_input("<color=#CCCCFF>[Pass]$ </color><color=#E6E6FA>",anon)
    else
		umaila=conf.mail.user
		umaill=conf.mail.pass
	end if
    mail=mail_login(umaila,umaill)
    if typeof(mail) == "string" then return error(mail)
    mails=mail.fetch
    for email in mails
        id=email.split("MailID: ")[1].split("\n")[0]
        print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Deleting "+id+"</color>")
        mail.delete(id)
    end for
    return out
end function

cmds.readmail=function(sin)
    out={}
    out.bool=1
    if not server.shell then
        umaila=user_input("<color=#CCCCFF>[Email]$ </color><color=#E6E6FA>",anon)
        umaill=user_input("<color=#CCCCFF>[Pass]$ </color><color=#E6E6FA>",anon)
    else
		umaila=conf.mail.user
		umaill=conf.mail.pass
	end if
    mail=mail_login(umaila,umaill)
    if typeof(mail) == "string" then return error(mail)
    mails=mail.fetch
    if mails.len == 0 then return out
    ids=[]
    num=0
    for email in mails
        id=email.split("MailID: ")[1].split("\n")[0]
        email=email.split("\n")[3:]
        from_=email[0].split("From: ")[1]
        subject=email[1].split("Subject: ")[1]
        email=email[2:-1].join("\n")
        print("<color=#CCCCFF>["+num+"]<br>[From] "+from_+"<br>[Subj] "+subject+"<br>"+email+"</color>")
        num=num+1
        ids.push(id)
    end for
    opt=user_input("<color=#CCCCFF>[#]$ </color><color=#E6E6FA>").to_int
    if opt > ids.len or opt < 0 then return out
    out.out=mail.read(ids[opt]).split(char(10))[2:].join(char(10))
    return out
end function

cmds.ls=function(sin)
    out={}
    out.bool=2
    if sin.len > 1 then return error("Invalid parameters", "ls")
    if sin.len == 1 then
        if shelltype == "file" then file=getFile(getPath(sin[0])) else file=comp.File(getPath(sin[0]))
    else
        if shelltype == "file" then file=shell else file=comp.File(xpath)
    end if
    if not file then return error("Path does not exist")
    if not file.is_folder then return error("Not a folder")

    output=[]
	l=["<color=#CCCCFF>"+file.name, file.owner, file.group, file.size, file.permissions+"</color>"]
	output.push(l.join(" "))
	l=["<color=#CCCCFF>[Name]","[Owner]","[Group]","[Size]","[Permissions]</color>\n"]
	output.push(l.join(" "))
	for f in file.get_folders+file.get_files
		l=[]
		l.push("<color=#CCCCFF>"+f.name)
		l.push(f.owner)
		l.push(f.group)
		l.push(f.size)
		l.push(f.permissions+"</color>")
		output.push(l.join(" "))
	end for
	print(format_columns(output.join("\n")))
	return out
end function

cmds.cd=function(sin)
    out={}
    out.bool=2
    if sin.len > 1 then return error("Invalid parameters", "cd")
    if sin.len == 0 then
        if shelltype == "file" then
			shell=getFile(home)
			if not shell then shell=getFile("/")
			globals.xpath=shell.path
			globals.shell=shell
		else
			globals.xpath=home
		end if
        return out
    end if
	path=getPath(sin[0])
    if shelltype == "file" then file=getFile(path) else file=comp.File(path)
    if not file then return error("Path does not exist")
    if not file.is_folder then return error("Not a folder")

    if shelltype == "file" then globals.shell=file
	globals.xpath=path
    globals.sessions[session].shell.path=xpath
    return out
end function

cmds.cat=function(sin)
    out={}
    out.bool=1
    if sin.len != 1 then return error("Invalid parameters", "cat")
    path=getPath(sin[0])
    if shelltype == "file" then file=getFile(path) else file=comp.File(path)
    if not file then return error("File does not exist")
    if not file.has_permission("r") then return error("No permissions to file")
    if file.is_folder then return error("Not a file")
    if file.is_binary then return error("Binary file, cannot read")
    out.out=file.get_content
    return out
end function

cmds.grep=function(sin)
    out={}
    out.bool=2
    if sin.len != 2 then return error("Invalid parameters", "grep")
    sin[1]=sin[1].split("\n")
    num=0
    for l in sin[1]
        if l.indexOf(sin[0]) != null then
            if pipe.len then
				out.bool=1
                out.out=l
                return out
            end if
            print("<color=#CCCCFF>["+sin[1].indexOf(l)+"] </color><color=#E6E6FA>"+l+"</color>")
            num=num+1
        end if
    end for
    if not num then return error("Could not find "+sin[0])
    return out
end function

cmds.echo=function(sin)
    out={}
    out.bool=1
    if sin.len == 0 then return error ("Invalid parameters", "echo")
    out.out=sin.join(" ")
    return out
end function

cmds.mkdir=function(sin)
    out={}
    out.bool=2
    if shelltype == "file" then return error("Cannot create directories with a file shell")
    if sin.len != 1 then return error("Invalid parameters", "mkdir")
    path=getPath(sin[0])
    name=path.split("/")[-1]
    if comp.File(path) then return error("File exists")
    path=parent_path(path)
    if not comp.File(path) then return error("Path does not exist")
    if not comp.File(path).is_folder then return error("Not a folder.")
    if not comp.File(path).has_permission("w") then return error("No permissions to path")
    comp.create_folder(path,name)
    print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Folder created successfully</color>")
    return out
end function

cmds.mv=function(sin)
    out={}
    out.bool=2
    if sin.len != 2 then return error("Invalid parameters", "mv")
    origFile=getPath(sin[0])
    destFolder=getPath(sin[1])
    if shelltype == "file" then file=getFile(origFile) else file=comp.File(origFile)
    if not file then return error("File does not exist")
    if shelltype == "file" then folder=getFile(destFolder) else folder=comp.File(destFolder)
    name=""
    if not folder then
        pathParent=parent_path(destFolder)
        if pathParent == destFolder then
            name=destFolder
            file.move(parent_path(file.path),name)
            return out
        else
            if shelltype == "file" then folder=getFile(pathParent) else folder=comp.File(pathParent)
            name=destFolder[destFolder.len-(destFolder.len-pathParent.len):]
            if name[0] == "/" then name=name[1:]
            if not folder then return error("Path does not exist")
        end if
    end if
    if folder then
        if parent_path(file.path) != parent_path(folder.path) or file.name != folder.name then
            finalDest=folder.path
            if name.len == 0 then name=file.name
            if not folder.is_folder then
                finalDest=parent_path(file.path)
                name=folder.name
            end if
            file.move(finalDest,name)
        end if
    end if
    print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>File moved successfully</color>")
    return out
end function

cmds.cp=function(sin)
    out={}
    out.bool=2
    if sin.len != 2 then return error("Invalid parameters", "cp")
    origFile=getPath(sin[0])
    destFolder=getPath(sin[1])
    if shelltype == "file" then file=getFile(origFile) else file=comp.File(origFile)
    if not file then return error("File does not exist")
    if shelltype == "file" then folder=getFile(destFolder) else folder=comp.File(destFolder)
    name=""
    if not folder then
        pathParent=parent_path(destFolder)
        if pathParent == destFolder then
            name=destFolder
            destFolder=file.parent.path
            file.copy(destFolder,name)
            return out
        else
            if shelltype == "file" then folder=getFile(pathParent) else folder=comp.File(pathParent)
            name=destFolder[destFolder.len-(destFolder.len-pathParent.len):]
            if name[0] == "/" then name=name[1:]
            if not folder then return error("Path does not exist")
        end if
    end if
    if folder then
        if parent_path(file.path) != parent_path(folder.path) or file.name != folder.name then
            finalDest=folder.path
            if name.len == 0 then name=file.name
            if not folder.is_folder then
                finalDest=parent_path(file.path)
                name=folder.name
            end if
            file.copy(finalDest,name)
        end if
    end if
    print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>File copied successfully</color>")
    return out
end function

cmds.touch=function(sin)
    out={}
    out.bool=2
    if shelltype == "file" then return error("Cannot create files with a file shell")
    if sin.len != 1 then return error("Invalid parameters", "touch")
    path=getPath(sin[0])
    name=path.split("/")[-1]
    if comp.File(path) then return error("File exists")
    path=parent_path(path)
    if not comp.File(path) then return error("Path does not exist")
    if not comp.File(path).is_folder then return error("Not a folder")
    if not comp.File(path).has_permission("w") then return error("No permissions to path")
    comp.touch(path,name)
    print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>File created successfully</color>")
    return out
end function

cmds.build=function(sin)
    out={}
    out.bool=2
    if shelltype != "shell" then return error("Shell required")
    if sin.len > 2 or sin.len == 0 then return error("Invalid parameters", "build")
    source=getPath(sin[0])
    dest=xpath
    if sin.hasIndex(1) then dest=getPath(sin[1])

    source=comp.File(source)
    dest=comp.File(dest)
    if not source then return error("Invalid source code file")
    if not dest then return error("Invalid destination")
    output=shell.build(source.path,dest.path)
    if output.len == 0 then
        print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Build successful</color>")
    else
        out.bool=0
        out.err=output
    end if
    return out
end function

cmds.shrink=function(sin)
	out={}
	out.bool=2
	if shelltype != "shell" then return error("Shell required")
	if sin.len != 2 then return error("Invalid parameters", "shrink")
	maxSize=sin[1].to_int
	if typeof(maxSize) != "number" then return error("Invalid size")
	path=getPath(sin[0])
	origSource=comp.File(path)
	if not origSource then return error("Invalid source code file")
	dest=parent_path(path)
	if not comp.File(dest) then return error("Invalid destination")
	alpha="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	al=alpha.len
	currLen=1
	counters={}
	start=time
	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Attempting to build "+sin[0]+" to "+maxSize+" or lower</color>")
	print("<align=right><color=#CCCCFF>-= <b><size=150%>-=-</size></b> =-</color></align>")
	while 1
		combo=al^currLen
		for i in range(0,combo)
			name=""
			for q in range(0,(currLen-1))
				counters["c"+q]={}
				c=counters["c"+q]
				if q == 0 then
					init=i
					c.c=init
				else
					init=counters["c"+(q-1)].c
					c.c=floor(init/al)
				end if
				c.i=c.c%al
				name=name+alpha[c.i]
			end for
			comp.touch(dest,name+".rawr")
			comp.File(dest+"/"+name+".rawr").set_content(origSource.get_content)
			shell.build(dest+"/"+name+".rawr",dest)
			comp.File(dest+"/"+name+".rawr").delete
			wait(0.1)
			if not comp.File(dest+"/"+name) then continue
			if comp.File(dest+"/"+name).size.to_int <= maxSize then
				diff=maxSize-comp.File(dest+"/"+name).size.to_int
				elapsed=(time-start)
				print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Finished in ["+elapsed+"] seconds.</color>")
				print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>"+name+" "+comp.File(dest+"/"+name).size+" - "+diff+"</color>")
				comp.File(dest+"/"+name).rename(origSource.name.split(".")[0])
				print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Renaming "+name+" to "+origSource.name.split(".")[0]+"</color>")
				return out
			end if
			comp.File(dest+"/"+name).delete
			counters={}
		end for
		currLen=currLen+1
	end while
	return out
end function

cmds.rm=function(sin)
	out={}
	out.bool=2
	if sin.len != 1 then return error("Invalid parameters", "rm")
	path=getPath(sin[0])
	if shelltype == "file" then file=getFile(path) else file=comp.File(path)
	if not file then return error("File does not exist")
	if not file.has_permission("w") then return error("No permissions to file")
	if shelltype == "file" then f=getFile(parent_path(path)) else f=comp.File(parent_path(path))
	if not f.has_permission("w") then return error("No permissions to path")
	if file.path == xpath then globals.xpath == parent_path(xpath)
	file.delete
	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>File deleted successfully</color>")
	return out
end function

cmds.chmod=function(sin)
	out={}
	out.bool=2
	if sin.len < 2 or sin.len > 3 then return error("Invalid parameters", "chmod")
	perms=sin[1]
	path=getPath(sin[0])
	if sin.len != 3 then rec=0 else rec=1
	if shelltype == "file" then file=getFile(path) else file=comp.File(path)
	if not file then return error("File does not exist")
	if not file.has_permission("w") and file.owner != xuser then return error("No permissions to file")
	if perms.indexOf("+") != null then
		perms=[perms[:perms.indexOf("+")],perms[perms.indexOf("+"):]]
	else if perms.indexOf("-") != null then
		perms=[perms[:perms.indexOf("-")],perms[perms.indexOf("-"):]]
	else
		return error("Invalid parameters", "chmod")
	end if
	if not perms[0] then perms[0]="oug"
	for perm in perms[0]
		file.chmod(perm+perms[1],rec)
	end for
	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>chmod successful</color>")
	return out
end function

cmds.addal=function(sin)
	out={}
	out.bool=2
	if sin.len != 2 then return error("Invalid parameters", "addal")
	if alias.hasIndex(sin[0]) then return error("This alias have already registered")
	globals.alias[sin[0]]=sin[1]
	if not af or not af.has_permission("w") then return out
	af.set_content(af.get_content+char(10)+sin[0]+":"+sin[1])
	return out
end function

cmds.delal=function(sin)
	out={}
	out.bool=2
	if sin.len != 1 then return error("Invalid parameters", "delal")
	if not alias.hasIndex(sin[0]) then return error("Alias hasn't found")
	if not af or not af.has_permission("w") then return error("No permissions to LuAliases.conf")
	con=af.get_content
	al=sin[0]+":"+alias[sin[0]]
	newcont=con[:con.indexOf(char(10)+alias)]+con[con.indexOf(al)+al.len:]
	af.set_content(newcont.join(char(10)))
	alias.remove(sin[0])
	return out
end function

cmds.chown=function(sin)
	out={}
	out.bool=2
	if sin.len < 2 or sin.len > 3 then return error("Invalid parameters", "chown")
	owner=sin[1]
	path=getPath(sin[0])
	if sin.len != 3 then rec=0 else rec=1
	if shelltype == "file" then file=getFile(path) else file=comp.File(path)
	if not file then return error("File does not exist")
	if not file.has_permission("w") and file.owner != xuser then return error("No permissions to file")
	file.set_owner(owner,rec)
	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Owner changed successfully</color>")
	return out
end function

cmds.chgrp=function(sin)
	out={}
	out.bool=2
	if sin.len < 2 or sin.len > 3 then return error("Invalid parameters", "chgrp")
	group=sin[1]
	path=getPath(sin[0])
	if sin.len != 3 then rec=0 else rec=1
	if shelltype == "file" then file=getFile(path) else file=comp.File(path)
	if not file then return error("File does not exist")
	if not file.has_permission("w") and file.owner != xuser then return error("No permissions to path")
	file.set_group(group,rec)
	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Group changed successfully</color>")
	return out
end function

cmds.sudo=function(sin)
	out={}
	out.bool=2
	if not origShell then return error("Cannot change user on a remote connection")
	if sin.len != 2 then return error("Invalid parameters", "sudo")
	sudosh=get_shell(sin[0],sin[1])
	if not sudosh then return error("Invalid username or password")
	globals.sessions[session].shells.push(sessions[sessions].shell)
	globals.shell=sudosh
	globals.origShell=0
	globals.xuser=sin[0]
	if sin[0] == "root" then globals.xpath="/root" else globals.xpath="/home/"+sin[0]
    if not shell.host_computer.File(xpath) then globals.xpath="/"
    globals.sessions[session].shell={"shell": shell, "user": xuser, "path": xpath, "orig": origShell}
	return out
end function

cmds.passwd=function(sin)
    out={}
    out.bool=2
    if shelltype == "file" then return error("Cannot change password with file shell")
    if sin.len != 2 then return error("Invalid parameters", "passwd")
    output=comp.change_password(sin[0],sin[1])
    if output==true then print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Password for "+sin[0]+" changed to "+sin[1]+"</color>")
    if typeof(output) == "string" then return error(output)
    return out
end function

cmds.useradd=function(sin)
	out={}
	out.bool=2
    if shelltype == "file" then return error("Cannot add users with file shell")
	if sin.len != 2 then return error("Invalid parameters", "useradd")
	output=comp.create_user(sin[0],sin[1])
	if output==true then print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>User "+sin[0]+" created</color>")
	if typeof(output) == "string" then return error(output)
	return out
end function

cmds.userdel=function(sin)
	out={}
	out.bool=2
    if shelltype == "file" then return error("Cannot delete users with file shell")
	if sin.len != 1 then return error("Invalid parameters", "userdel")
	output=comp.delete_user(sin[0],1)
	if output==true then print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>User "+sin[0]+" deleted</color>")
	if typeof(output) == "string" then return error(output)
	return out
end function

cmds.groups=function(sin)
	out={}
	out.bool=2
    if shelltype == "file" then return error("Cannot view user groups with file shell")
	if sin.len != 1 then return error("invalid parameters", "groups")
	output=comp.groups(sin[0])
	if not output then return out
	print(output)
	return out
end function

cmds.groupadd=function(sin)
	out={}
	out.bool=2
    if shelltype == "file" then return error("Cannot add groups with file shell")
	if sin.len != 2 then return error("Invalid parameters", "groupadd")
	output=comp.create_group(sin[0],sin[1])
	if output==true then
		print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>"+sin[1]+" added to user "+sin[0]+"</color>")
		return out
	end if
	return error(output)
end function

cmds.groupdel=function(sin)
	out={}
	out.bool=0
    if shelltype == "file" then return error("Cannot delete groups with file shell")
	if sin.len != 2 then return error("Invalid parameters", "groupdel")
	output=comp.delete_group(sin[0],sin[1])
	if output==true then
		print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>"+sin[1]+" removed from user "+sin[0]+"</color>")
		return out
	end if
	return error(output)
end function

cmds.bash=function(sin)
	out={}
	out.bool=2
	if shelltype != "shell" then return error("Shell required")
	if sin.len == 0 then return error("Invalid parameters", "bash")
	path=getPath(sin[0])
	prog=path
	if not comp.File(prog) then return error("File does not exist")
	if not comp.File(prog).has_permission("x") then return error("No permissions to file")
	sin.pull
	xparams=sin.join(" ")
	shell.launch(prog,xparams)
	return out
end function

cmds.ps=function(sin)
	out={}
	out.bool=2
    if shelltype == "file" then return error("Cannot list processes with file shell")
	bar = function(n, bar_length = 35) // percentage number
		fill_count = ceil(n / bar_length * 10)
		empty_count = bar_length - fill_count
	
		fill_bar = "#"*fill_count
		empty_bar = "-"*empty_count
	
		bar = "<color=#21bcff>"+fill_bar+"</color><color=#032e41>"+empty_bar+"</color>"
		return bar
	end function

	ps_out = comp.show_procs
	tasks = 0
	cpu_load = 0.0
	mem_load = 0.0
	users = []

	// convert ps output to a map
	counter = 0
	for l in ps_out.split("\n")[1:]
		l = l.split(" ")
	
		cpu_load = cpu_load + l[2][:-1].val
		mem_load = mem_load + l[3][:-1].val
	
		if l[0] == "root" then
			u = "<color=#ff4b4b>"+l[0]+"</color>"
		else
			u = "<color=#CCCCFF>"+l[0]+"</color>"
		end if

		n = "<color=#20ff98>"+l[1]+"</color>"
		c = "<color=#21bcff>"+l[2]+"</color>"
		m = "<color=#21bcff>"+l[3]+"</color>"
		p = "<color=#baff50>"+l[4]+"</color>"
		imp=0
		for i in users
			if i.u == u then
				i.t.push({"n": n, "c": c, "m": m, "p": p})
				imp=1
			end if
		end for
		if not imp then
			mp={}
			mp.u=u
			mp.t=[]
			mp.t.push({"n": n, "c": c, "m": m, "p": p})
			users.push(mp)
		end if
	
		tasks=tasks+1
	end for
	print("<color=#fbfbfb>tasks: "+tasks+"</color>")
	if tasks > 0 then
	print("<color=#fbfbfb>cpu_usage: [</color>"+bar(cpu_load)+"<color=#fbfbfb>]==[ </color><color=#21bcff>"+cpu_load+"%</color> <color=#fbfbfb>]</color>")
	print("<color=#fbfbfb>mem_usage: [</color>"+bar(mem_load)+"<color=#fbfbfb>]==[ </color><color=#21bcff>"+mem_load+"%</color> <color=#fbfbfb>]</color>\n")
	end if
	// print ps with colors
	pps = []
	ps = ps_out.split("\n")
	print("<color=#9d9d9d>-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-</color>")

	for m in users
		pps.push(m.u)
		for t in m.t
			l=[t.n, t.c, t.m, t.p]
			pps.push(l.join(" "))
		end for
		pps.push("<color=#9d9d9d>X</color>")
	end for

	print(format_columns(pps.join("\n")))
	return out
end function

cmds.monitor=function(sin)
	out={}
	out.bool=2
    if shelltype == "file" then return error("Cannot list processes with file shell")
	bar = function(n, bar_length = 35) // percentage number
		fill_count = ceil(n / bar_length * 10)
		empty_count = bar_length - fill_count
	
		fill_bar = "#"*fill_count
		empty_bar = "-"*empty_count
	
		bar = "<color=#21bcff>"+fill_bar+"</color><color=#032e41>"+empty_bar+"</color>"
		return bar
	end function
	secs = 60
	if sin.len == 1 then secs = sin[0]
	print("<color=#CCCCFF>-Start Monitor-</color>")
	print("<color=#CCCCFF>-Please, wait-</color>")
	wait(1)
	while secs != 0 
		clear_screen
		ps_out = comp.show_procs
		tasks = 0
		cpu_load = 0.0
		mem_load = 0.0
		users = []

		// convert ps output to a map
		counter = 0
		for l in ps_out.split("\n")[1:]
			l = l.split(" ")
		
			cpu_load = cpu_load + l[2][:-1].val
			mem_load = mem_load + l[3][:-1].val
		
			if l[0] == "root" then
				u = "<color=#ff4b4b>"+l[0]+"</color>"
			else
				u = "<color=#CCCCFF>"+l[0]+"</color>"
			end if

			n = "<color=#20ff98>"+l[1]+"</color>"
			c = "<color=#21bcff>"+l[2]+"</color>"
			m = "<color=#21bcff>"+l[3]+"</color>"
			p = "<color=#baff50>"+l[4]+"</color>"
			imp=0
			for i in users
				if i.u == u then
					i.t.push({"n": n, "c": c, "m": m, "p": p})
					imp=1
				end if
			end for
			if not imp then
				mp={}
				mp.u=u
				mp.t=[]
				mp.t.push({"n": n, "c": c, "m": m, "p": p})
				users.push(mp)
			end if
		
			tasks=tasks+1
		end for
		print("<color=#fbfbfb>tasks: "+tasks+"</color>")
		if tasks > 0 then
		print("<color=#fbfbfb>cpu_usage: [</color>"+bar(cpu_load)+"<color=#fbfbfb>]==[ </color><color=#21bcff>"+cpu_load+"%</color> <color=#fbfbfb>]</color>")
		print("<color=#fbfbfb>mem_usage: [</color>"+bar(mem_load)+"<color=#fbfbfb>]==[ </color><color=#21bcff>"+mem_load+"%</color> <color=#fbfbfb>]</color>\n")
		end if
		// print ps with colors
		pps = []
		ps = ps_out.split("\n")
		print("<color=#9d9d9d>-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-</color>")

		for m in users
			pps.push(m.u)
			for t in m.t
				l=[t.n, t.c, t.m, t.p]
				pps.push(l.join(" "))
			end for
			pps.push("<color=#9d9d9d>X</color>")
		end for

		print(format_columns(pps.join("\n")))
		secs = secs - 1
		wait(1)
	end while
	return out
end function

cmds.kill=function(sin)
	out={}
	out.bool=2
    if shelltype == "file" then return error("Cannot kill processes with file shell")
	if sin.len != 1 then return error("Invalid parameters", "kill")
	if sin[0] == "all" then
		procs=comp.show_procs.split("\n")
		procs.pull
		for proc in procs
			proc=proc.split(" ")
			if proc[-1] == Lunarium.split("/")[-1] and origShell == 1 then continue
			output=comp.close_program(proc[1].to_int)
			if output==true then print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Killed process "+proc[1]+"</color>")
			if typeof(output) == "string" then print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>"+output+"</color>")
			wait(0.1)
		end for
		return out
	end if
	output=comp.close_program(sin[0].to_int)
	if output==true then
		print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Killed process "+sin[0]+"</color>")
		return out
	end if
	if output then return error(output)
	out.bool=0
	out.err="Process "+sin[0]+" not found"
	return out
end function

cmds.ssh=function(sin)
    out={}
    out.bool=2
    if shelltype != "shell" then return error("Shell required")
	if not comp.is_network_active() then return error("Internet connection required")
    if sin.len < 2 or sin.len > 4 then return error("Invalid parameters", "ssh")
    acc=sin[0]
    pass=sin[1]
    serv=rhost
    port=22
    if sin.len >= 3 then serv=sin[2]
    if sin.len == 4 then
        port=sin[3].to_int
        if typeof(port) != "number" then return error("Invalid port")
    end if
    print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Establishing connection...</color>")
    ssh=shell.connect_service(serv,port,acc,pass,"ssh")
    if typeof(ssh) == "shell" then
        globals.sessions[session].shells.push(globals.sessions[session].shell)
        globals.shell=ssh
        globals.origShell=0
        globals.xuser=acc
        if acc == "root" then globals.xpath="/root" else globals.xpath="/home/"+acc
        if not shell.host_computer.File(xpath) then globals.xpath="/"
        globals.sessions[session].shell={"shell": shell, "path": xpath, "user": xuser, "orig": origShell}
    else
        out.bool=0
        out.err="Could not establish connection"
    end if
    return out
end function

// cmds.vpn=function(sin)
//     out={}
//     out.bool=2
//     if shelltype != "shell" then return error("Shell required")
//     if sin.len < 2 or sin.len > 4 then return error("Invalid parameters")
//     acc=sin[0]
//     pass=sin[1]
//     serv=rhost
//     port=22
//     if sin.len >= 3 then serv=sin[2]
//     if sin.len == 4 then
//         port=sin[3].to_int
//         if typeof(port) != "number" then return error("Invalid port")
//     end if
//     print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Establishing connection...</color>")
//     ssh=server.shell.connect_service(serv,port,acc,pass,"ssh")
//     if typeof(ssh) == "shell" then
//         globals.sessions[session].shells.push(globals.sessions[session].shell)
//         globals.shell=ssh
//         globals.origShell=0
//         globals.xuser=acc
//         if acc == "root" then globals.xpath="/root" else globals.xpath="/home/"+acc
//         if not shell.host_computer.File(xpath) then globals.xpath="/"
//         globals.sessions[session].shell={"shell": shell, "path": xpath, "user": xuser, "orig": origShell}
//     else
//         out.bool=0
//         out.err="Could not establish connection"
//     end if
//     return out
// end function

cmds.shell=function(sin)
    out={}
    out.bool=2
    if shelltype != "shell" then return error("Shell required")
	if not comp.is_network_active() then return error("Internet connection required")
    if sin.len > 1 then return error("Invalid parameters", "shell")
    if sin.len == 1 and comp.File(xpath) and comp.File(xpath).has_permission("w") then
		get_shell.host_computer.File(Lunarium).chmod("o+rx")
		get_shell.host_computer.File(Lunarium).chmod("u+rx")
		get_shell.host_computer.File(Lunarium).chmod("g+rx")
        print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Uploading Lunarium</color>\n")
        get_shell.scp(Lunarium,xpath,shell)
		get_shell.host_computer.File(mxf).chmod("o+rx")
		get_shell.host_computer.File(mxf).chmod("u+rx")
		get_shell.host_computer.File(mxf).chmod("g+rx")
        print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Uploading metaxploit</color>\n")
        get_shell.scp(mxf,xpath,shell)
		get_shell.host_computer.File(cpf).chmod("o+rx")
		get_shell.host_computer.File(cpf).chmod("u+rx")
		get_shell.host_computer.File(cpf).chmod("g+rx")
        print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Uploading crypto</color>\n")
        get_shell.scp(cpf,xpath,shell)
		if la then
			comp.touch(xpath,"LuDB")
			print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Uploading Lunarium DB</color>\n")
			comp.File(xpath+"/LuDB").set_content(dbfile.get_content)
		end if
        if scnln and sin[0].indexOf("s") != null then
			get_shell.host_computer.File(scnln).chmod("o+rx")
			get_shell.host_computer.File(scnln).chmod("u+rx")
			get_shell.host_computer.File(scnln).chmod("g+rx")
            print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Uploading ScanLan</color>\n")
            get_shell.scp(scnln,xpath,shell)
        end if
    end if
    print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Starting shell at "+comp.public_ip+", come back soon!</color>")
    shell.start_terminal
    return out
end function

cmds.put=function(sin)
	out={}
	out.bool=2
	if shelltype != "shell" then return error("Shell required")
	if not comp.is_network_active() then return error("Internet connection required")
	if sin.len < 1 or sin.len > 2 then return error("Invalid parameters", "put")
	if not get_shell.host_computer.File(sin[0]) then return error("File does not exist")
	if not get_shell.host_computer.File(sin[0]).has_permission("r") then return error("No permissions to file")
	if sin.len == 2 then path=getPath(sin[1]) else path=xpath
	if not comp.File(path) then return error("Path does not exist")
	if not comp.File(path).has_permission("w") then return error("No permissions to path")
	get_shell.scp(sin[0],path,shell)
	return out
end function

cmds.get=function(sin)
	out={}
	out.bool=2
	if shelltype != "shell" then return error("Shell required")
	if not comp.is_network_active() then return error("Internet connection required")
	if sin.len < 1 or sin.len > 2 then return error("Invalid parameters", "get")
	path=getPath(sin[0])
	if not comp.File(path) then return error("File does not exist")
	if not comp.File(path).has_permission("r") then return error("No permissions to file")
	if sin.len == 2 then lpath=sin[1] else lpath=current_path
	if not get_shell.host_computer.File(lpath) then return error("Path does not exist")
	if not get_shell.host_computer.File(lpath).has_permission("w") then return error("No permissions to path")
	shell.scp(path,lpath,get_shell)
	return out
end function

cmds.set=function(sin)
    out={}
    out.bool=2
    if sin.len != 2 then return error("Invalid parameters", "set")
	var=sin[0]
	set=sin[1]

    if var == "user" then globals.xuser=set
	return out
end function

cmds.info=function(sin)
    out={}
    out.bool=2
	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>RHost: "+rhost+"</color>")
	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Session: "+session+"</color>")
    return out
end function

cmds.rhost=function(sin)
    out={}
    out.bool=2
	if shelltype != "file" then
		if not comp.is_network_active() then
			return error("Internet connection required")
		end if
	end if
    if sin.len > 1 then return error("Invalid parameters", "rhost")
    if sin.len == 0 then
        if shelltype == "file" then
            globals.rhost=globals.sessions[session].shell.pubip
        else
            globals.rhost=comp.network_gateway
            if rhost == "0.0.0.0" then globals.rhost=comp.local_ip
        end if
    else
        if sin[0][:3] == "www" then sin[0]=nslookup(sin[0])
        router=get_router(sin[0])
        if is_lan_ip(sin[0]) then router=get_router
        if not router then return error("Invalid address")
        globals.rhost=sin[0]
    end if
    if rhost == pubip and anon then print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>RHost: x.x.x.x</color>") else print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>RHost: "+rhost+"</color>")
    globals.sessions[session].rhost=rhost
    return out
end function

cmds.random=function(sin)
    out={}
    out.bool=2
	if shelltype != "file" then
		if not comp.is_network_active() then
			return error("Internet connection required")
		end if
	end if
    ip=null
    while not get_router(ip)
        ip=getRandomIp
    end while
    globals.rhost=ip
    print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>RHost: "+rhost+"</color>")
    globals.sessions[session].rhost=rhost
    return out
end function

cmds.nmap=function(sin)
	out={}
	out.bool=2
	if shelltype != "file" then
		if not comp.is_network_active() then
			return error("Internet connection required")
		end if
	end if
    if sin.len then
        if sin[0][:3] == "www" then sin[0]=nslookup(sin[0])
        locals.rhost=sin[0]
    end if
	islan=is_lan_ip(rhost)
	router=get_router(rhost)
	if islan then router=get_router
	if not router then return error("Invalid address")
	wifi=router.essid_name
	bssid=router.bssid_name
	rver=router.kernel_version
	fwr=router.firewall_rules
	if islan then
		ports=router.device_ports(rhost)
	else
		ports=router.used_ports
	end if
	ips=[]
	if rhost != router.local_ip then
		hport=null
		if router.device_ports(router.local_ip).len then hport=router.device_ports(router.local_ip)[0]
		m={}
		m.ip=router.local_ip
		m.ports=[]
		if hport then m.ports.push(hport)
		ips.push(m)
		m=null
	end if
	fwinfo="action port source dest"
	for rules in fwr
		fwinfo=fwinfo+"\n"+rules
	end for
	extinfo="<color=white>"+rhost+"</color><color=#CCCCFF>|wifi: "+wifi+" |bssid: "+bssid+"</color>"
	info="# lan port status service version"
	print(extinfo)
	if fwr then print(format_columns(fwinfo))
	num=0
	
	// working around the bug when the program crashes
	// if you use nmap under certain conditions
	for port in ports
		if typeof(port) != "port" then
			ports.remove(port)
		end if
	end for

	for port in ports
		inMap=0
		for m in ips
			if m.ip == port.get_lan_ip then
				m.ports.push(port)
				inMap=1
			end if
		end for
		if not inMap then
			m={}
			m.ip=port.get_lan_ip
			m.ports=[port]
			ips.push(m)
		end if
	end for
	for m in ips
		ports=m.ports
		ip=m.ip
		info=info+"\n"+num+" "+ip+" \"
		if ip == router.local_ip then info=info+"\n - |0 routed router "+rver
		for port in ports
			service=router.port_info(port)
			status="routed"
			if port.is_closed then status="closed"
			info=info+"\n - |"+port.port_number+" "+status+" "+service
		end for
		num=num+1
	end for
	if not islan or rhost[-2:] == ".1" then; for sub in router.devices_lan_ip
		subIn=0
		for m in ips
			if sub == m.ip then subIn=1
		end for
		if subIn then continue
		info=info+"\n"+num+" "+sub
		num=num+1
	end for;end if
	print(format_columns(info)+"\n")
	whoisinfo=whois(rhost).split("\n")
	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>WhoIs results</color>")
	if whoisinfo.len < 3 then
		print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Could not perform WhoIs operation</color>")
		return out
	end if
	print("<color=#CCCCFF>"+whoisinfo[0]+"<br>"+whoisinfo[1]+"<br>"+whoisinfo[2]+"</color>")
	return out
end function

cmds.target=function(sin)
    out={}
    out.bool=2
	if shelltype != "file" then
		if not comp.is_network_active() then
			return error("Internet connection required")
		end if
	end if
    globals.args=null
    rinfo=[["<color=#CCCCFF>[Num]","[Object]","[Perms]","[Lan]","[PubIP]","[Port]</color>"].join(" ")]
    if sin.len > 2 then return error("Invalid parameters", "target")
	if sin.len == 0 or sin[0] == "all" then
		for port in get_router(rhost).used_ports
			globals.expport=port.port_number
			print(expport)
			if typeof(expport) != "number" then
				print("Invalid port")
				continue
			end if
			if sin.len == 2 then globals.args=sin[1]
			if server.shell then
				server.shell.launch("/root/rcon")
				lmx=COB.server.mx
			else
				lmx=mx
			end if
			globals.lmx=lmx
			ns=mx.net_use(rhost,expport)
			if not ns then
				print("Cannot establish net session")
				continue
			end if
			globals.ml=ns.dump_lib
			if server.shell then
				getExploits
				inDB=0
				for dblib in exploits
					if ml.lib_name == dblib.name and ml.version == dblib.ver then inDB=1
				end for
			end if
			if dbfile then
				getExploits
				globals.lib=null
				for dblib in exploits
					if ml.lib_name == dblib.name and ml.version == dblib.ver then
						globals.lib=dblib
						break
					end if
				end for
				saveScan()
			else
				Scan()
			end if
		end for
	else
		globals.expport=sin[0].to_int
		if typeof(expport) != "number" then return error("Invalid port")
		if sin.len == 2 then globals.args=sin[1]
		if server.shell then
			server.shell.launch("/root/rcon")
			lmx=COB.server.mx
		else
			lmx=mx
		end if
		globals.lmx=lmx
		ns=mx.net_use(rhost,expport)
		if not ns then return error("Cannot establish net session")
		globals.ml=ns.dump_lib
		if server.shell then
			getExploits
			inDB=0
			for dblib in exploits
				if ml.lib_name == dblib.name and ml.version == dblib.ver then inDB=1
			end for
		end if
		if dbfile then
			getExploits
			globals.lib=null
			for dblib in exploits
				if ml.lib_name == dblib.name and ml.version == dblib.ver then
					globals.lib=dblib
					break
				end if
			end for
			saveScan()
		else
			Scan()
		end if
	end if

	exps={"root": [], "user": [], "guest": []}
	for ex in results
		if ex.user == "root" then
			exps.root.push(ex)
		else if ex.user == "guest" then
			exps.guest.push(ex)
		else
			exps.user.push(ex)
		end if
	end for
	results=exps.root+exps.user+exps.guest
	exps={"shell": [], "comp": [], "file": []}
	for ex in results
		if typeof(ex.obj) == "shell" then
			exps.shell.push(ex)
		else if typeof(ex.obj) == "computer" then
			exps.comp.push(ex)
		else if typeof(ex.obj) == "file" then
			exps.file.push(ex)
		end if
	end for
	results=exps.shell+exps.comp+exps.file
    globals.sessions[session].results=results
    for ex in results
        rinfo.push(["<color=#CCCCFF>["+__ex_idx+"]",ex.obj,ex.user,ex.lan,ex.pub,ex.port+"</color>"].join(" "))
    end for
	globals.results=results
    globals.rinfo=rinfo
    print(format_columns(rinfo.join("\n")))
    return out
end function

cmds.escalate=function(sin)
    out={}
    out.bool=2
    globals.args=null

	//if shelltype != "file" then // this is escalation, i don't entirely believe it requires internet connection.
	//	if not comp.is_network_active() then
	//		return error("Internet connection required")
	//	end if
	//end if

	// as escalate does not works on a remote connection - why allowing user to use it on it?
	// because i decided it would be nice to still be able to escalate/hack on the local machine while connected to something else remotely. it was actually rather useful! maybe instead a warning that its escalating the local machine would've been better though -Clover
	// using your same logic however target also does not work on a remote connection. technically -Clover
	if not origShell then return error("Can't use escalate on a remote connection")

    rinfo=[["<color=#CCCCFF>[Num]","[Object]","[Perms]","[Lan]","[PubIP]","[Port]</color>"].join(" ")]
    if sin.len > 1 then return error("Invalid parameters", "escalate")
    if sin.len == 1 then globals.args=sin[0]
    libs=comp.File("/lib")
	if server.shell then
		server.shell.launch("/root/rcon")
		lmx=COB.server.mx
	else
		lmx=mx
	end if
	globals.lmx=lmx
    for exlib in libs.get_files
        globals.ml=mx.load(exlib.path)
        if not ml then continue
        if args then print(format_columns("LIB ARGS\n"+exlib.name+" "+args+"\n")) else print(format_columns("LIB\n"+exlib.name+"\n"))
		if dbfile or server.shell then
			getExploits
			globals.lib=null
			for dblib in exploits
				if ml.lib_name == dblib.name and ml.version == dblib.ver then
					globals.lib=dblib
					break
				end if
			end for
			saveScan()
		else
			Scan()
		end if
    end for
	exps={"root": [], "user": [], "guest": []}
	for ex in results
		if ex.user == "root" then
			exps.root.push(ex)
		else if ex.user == "guest" then
			exps.guest.push(ex)
		else
			exps.user.push(ex)
		end if
	end for
	results=exps.root+exps.user+exps.guest
	exps={"shell": [], "comp": [], "file": []}
	for ex in results
		if typeof(ex.obj) == "shell" then
			exps.shell.push(ex)
		else if typeof(ex.obj) == "computer" then
			exps.comp.push(ex)
		else if typeof(ex.obj) == "file" then
			exps.file.push(ex)
		end if
	end for
	results=exps.shell+exps.comp+exps.file
    globals.sessions[session].results=results
    for ex in results
        rinfo.push(["<color=#CCCCFF>["+__ex_idx+"]",ex.obj,ex.user,ex.lan,ex.pub,ex.port+"</color>"].join(" "))
    end for
    globals.rinfo=rinfo
	globals.results=results
    print(format_columns(rinfo.join("\n")))
    return out
end function

cmds.results=function(sin)
    out={}
    out.bool=2
    if sin.len == 1 and sin[0] == "-c" then
        globals.results=[]
        globals.sessions[session].results=results
        globals.rinfo=null
        print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Cleared results</color>")
        return out
    end if
    if not results.len then return error("No exploits found")
    print(format_columns(rinfo.join("\n")))
    return out
end function

cmds.use=function(sin)
    out={}
    out.bool=2
	//if shelltype != "file" then // pretty sure this check is entirely useless here. shouldn't matter if you're internet connected or not if you already have the resulting objects
	//	if not comp.is_network_active() then
	//		return error("Internet connection required")
	//	end if
	//end if
    if not results.len then return error("No exploits found")
    if sin.len != 1 then return error("Invalid parameters", "use")
    num=sin[0].to_int
    if typeof(num) != "number" or num > results.len or num < 0 then return error("Invalid selection")
    ex=results[num]
    result=ex.obj
    globals.sessions[session].shells.push(globals.sessions[session].shell)
    if typeof(result) != "file" then
        shell=result
        comp=shell
        if typeof(shell) == "shell" then comp=shell.host_computer
        xuser=ex.user
        if ex.user == "root" then xpath="/root" else xpath="/home/"+xuser
        if not comp.File(xpath) then xpath="/"
        globals.sessions[session].shell={"shell": shell, "user": xuser, "path": xpath, "orig": 0}
		globals.shell=shell
		globals.origShell=0
		globals.comp=comp
		globals.xuser=xuser
		globals.xpath=xpath
        print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Checking for active admins...</color>")
        procs=comp.show_procs.split("\n")[1:]
        admin=0
        for proc in procs
            proc=proc.split(" ")[-1]
            if proc == "dsession" then admin=1
            if proc == "Xorg" then admin=2
        end for
        if admin == 1 then
            print("<color=red><b>ACTIVE ADMIN DETECTED!</b></color>")
        else if admin == 2 then
            print("<color=red><b>ACTIVE PLAYER DETECTED!</b></color>")
        else
            print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>No admins detected</color>")
        end if
    else
		shell=result
		comp=result
		while comp.path != "/"
			comp=comp.parent
		end while
		xuser=ex.user
		xpath=shell.path
		globals.sessions[session].shell={"shell": shell, "user": xuser, "path": xpath, "orig": 0, "pubip": ex.pub, "locip": ex.lan}
        globals.shell=shell
        globals.origShell=0
        globals.comp=comp
		globals.xuser=xuser
        globals.xpath=shell.path
    end if
	return out
end function

cmds.rshell=function(sin)
    out={}
    out.bool=2
	
	//if shelltype != "file" then // And why this check for the commands that already check "origShell"? The origShell check will automatically filter these out and you can do a simple one-line check for internet directly afterwards
	//	if not comp.is_network_active() then
	//		return error("Internet connection required")
	//	end if
	//end if
    if not origShell then return error("Cannot run an rshell on a remote connection")
	if not comp.is_network_active() then return error("Internet connection required")
    if sin.len() != 3 then return error("Invalid parameters", "rshell")
    rsport=1222
    if sin.len >= 1 then rip=sin[0]
    if sin.len >= 2 then uproc=sin[1]
    if sin.len == 3 then
        rsport=sin[2].to_int
        if typeof(rsport) != "number" then return error("Invalid port")
    end if
    mx.rshell_client(rip, rsport, uproc)
    return out
end function

// cmds.rss=function(sin)
//     out={}
//     out.bool=2
//     if not origShell then return error("Cannot receive rshell connections on a remote connection")
//     if not server.shell then return error("Server connection required")
//     print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Connecting to rshell server...</color>")
//     rsc=server.shell.connect_service(conf.rss.ip,conf.rss.port,conf.rss.user,conf.rss.pass)
//     if typeof(rsc) == "shell" then
//         print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Connected successfully</color>")
//     else
// 		return error("Could not connect")
//     end if
//     if not rsc.host_computer.File("/root/shell") then rsc.host_computer.touch("/root","shell")
//     rsfile="/root/rss"
//     rsc.launch(rsfile)
// 	rsinfo="num pubip locip user\n"
//     rshells=COB.rshells
// 	opt=null
// 	print(rshells.len+" shells")
// 	for i in range(0,rshells.len-1)
// 		rfile=rshells[i].host_computer.File("/root")
// 		ruser="guest"
// 		if rfile and rfile.has_permission("w") then
// 			ruser="root"
// 		else
// 			rfile=rshells[i].host_computer.File("/home")
// 			if rfile then
// 				for user in rfile.get_folders
// 					if user.name == "guest" then continue
// 					if user.has_permission("w") then ruser=user.name
// 				end for
// 			end if
// 		end if
// 		rsinfo=rsinfo+"\n"+i+"| "+rshells[i].host_computer.public_ip+" "+rshells[i].host_computer.local_ip+" "+ruser
// 	end for
// 	print(format_columns(rsinfo))
// 	while opt > rshells.len-1 or opt < 0 or typeof(opt) != "number"
// 		opt=user_input("<color=#CCCCFF>[#]$ </color><color=#E6E6FA>").to_int
// 		if opt == "b" then return out
// 	end while
// 	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Starting shell #"+opt+"</color>")
// 	rfile=rshells[opt].host_computer.File("/root")
// 	ruser="guest"
// 	if rfile and rfile.has_permission("w") then
// 		ruser="root"
// 	else
// 		rfile=rshells[opt].host_computer.File("/home")
// 		if rfile then
// 			for user in rfile.get_folders
// 				if user.name == "guest" then continue
// 				if user.has_permission("w") then ruser=user.name
// 			end for
// 		end if
// 	end if
//     globals.sessions[session].shells.push(globals.sessions[session].shell)
// 	globals.shell=rshells[opt]
// 	globals.origShell=0
// 	globals.xuser=ruser
// 	if xuser == "root" then globals.xpath="/root" else globals.xpath="/home/"+xuser
// 	if not shell.host_computer.File(xpath) then globals.xpath="/"
//     globals.sessions[session].shell={"shell": shell, "user": xuser, "path": xpath, "orig": origShell}
// 	return out
// end function

cmds.rsi=function(sin)
	out={}
	out.bool=2
	//if shelltype != "file" then
	//	if not comp.is_network_active() then
	//		return error("Internet connection required")
	//	end if
	//end if
	if not origShell then return error("Cannot receive rshell connections on a remote connection")
	if not comp.is_network_active() then return error("Internet connection required")
	if not include_lib("/lib/librshell.so") then return error("No rshell server installed")
	rsinfo="num pubip locip user\n"
	rshells=[]
	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Waiting for connections. . .</color>")
	while rshells.len == 0
		rshells=mx.rshell_server
		if rshells.len == 0 then wait(2)
	end while
	if typeof(rshells) == "string" then return error(rshells)
	opt=null
	print(rshells.len+" shells")
	for i in range(0,rshells.len-1)
		rfile=rshells[i].host_computer.File("/root")
		ruser="guest"
		if rfile and rfile.has_permission("w") then
			ruser="root"
		else
			rfile=rshells[i].host_computer.File("/home")
			if rfile then
				for user in rfile.get_folders
					if user.name == "guest" then continue
					if user.has_permission("w") then ruser=user.name
				end for
			end if
		end if
		rsinfo=rsinfo+"\n"+i+"| "+rshells[i].host_computer.public_ip+" "+rshells[i].host_computer.local_ip+" "+ruser
	end for
	print(format_columns(rsinfo))
	while opt > rshells.len-1 or opt < 0 or typeof(opt) != "number"
		opt=user_input("<color=#CCCCFF>[#]$ </color><color=#E6E6FA>").to_int
		if opt == "b" then return out
	end while
	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Starting shell #"+opt+"</color>")
	rfile=rshells[opt].host_computer.File("/root")
	ruser="guest"
	if rfile and rfile.has_permission("w") then
		ruser="root"
	else
		rfile=rshells[opt].host_computer.File("/home")
		if rfile then
			for user in rfile.get_folders
				if user.name == "guest" then continue
				if user.has_permission("w") then ruser=user.name
			end for
		end if
	end if
    globals.sessions[session].shells.push(globals.sessions[session].shell)
	globals.shell=rshells[opt]
	globals.origShell=0
	globals.xuser=ruser
	if xuser == "root" then globals.xpath="/root" else globals.xpath="/home/"+xuser
	if not shell.host_computer.File(xpath) then globals.xpath="/"
    globals.sessions[session].shell={"shell": shell, "user": xuser, "path": xpath, "orig": origShell}
	return out
end function

cmds.sniffer=function(sin)
	out={}
	out.bool=2
	//if shelltype != "file" then
	//	if not comp.is_network_active() then
	//		return error("Internet connection required")
	//	end if
	//end if
	if not origShell then return error("Cannot sniff connections on a remote connection")
	if not comp.is_network_active() then return error("Internet connection required")
	if sin.len > 1 then return error("Invalid parameters", "sniffer")
	save=0
	if sin.len == 1 then save=1
	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Waiting for network traffic. . .</color>")
	output=mx.sniffer(save)
	if not output then return error("Failed to listen to network traffic")
	print(output)
	return out
end function

cmds.iwctl=function(sin)
	out={}
	out.bool=2
	if shelltype == "file" then return error("Cannot change WiFi on a Filetype shell")
	if sin.len != 3 then return error("Invalid parameters", "iwctl")
	if comp.active_net_card != "WIFI" then return error("Cannot use ethernet")
	check=comp.connect_wifi("wlan0",sin[0],sin[1],sin[2])
	if check != 1 then return error(check)
	return out
end function

cmds.net=function(sin)
	out={}
	out.bool=2
	if shelltype == "file" then return error("Cannot list WiFi networks on a Filetype shell")
	if comp.active_net_card != "WIFI" then return error("Cannot use ethernet")
	print comp.wifi_networks("wlan0").join(char(10))
	return out
end function

cmds.inet=function(sin)
	out={}
	out.bool=1
	if not origShell then return error("Cannot hack wifi connections on a remote connection")
	if sin.len > 2 then return error("Invalid parameters", "inet")
	winfo="# BSSID POWER ESSID"
	num=0
	sel=null
	nd=comp.network_devices
	an=comp.active_net_card
	if an != "WIFI" then return error("Cannot use ethernet")
	cp.airmon("start","wlan0")
	wifis=comp.wifi_networks("wlan0")
	if sin.len < 2 then
		for wifi in wifis
			winfo=winfo+"\n"+num+" "+wifi
			num=num+1
		end for
		print(format_columns(winfo))
		while sel > wifis.len or sel < 0 or typeof(sel) != "number"
			sel=user_input("#> ").to_int
			if sel == "b" then break
		end while
		if sel == "b" then
			out.bool=2
			return out
		end if
		wifi=wifis[sel].split(" ")
		pwr=wifi[1]
		pwr=pwr[:pwr.len-1].to_int
		bssid=wifi[0]
		essid=wifi[2]
		maxacks=300000/pwr
		cp.aireplay(bssid,essid,maxacks)
	else
		bssid=sin[0]
		essid=sin[1]
		cp.aireplay(bssid,essid,300000)
	end if
	out.out=cp.aircrack(current_path+"/file.cap")
	return out
end function

cmds.mailbomb=function(sin)
	out={}
	out.bool=2
	if sin.len != 4 then return error("Invalid parameters", "mailbomb")
	if not server.shell then
        umaila=user_input("<color=#CCCCFF>[Email]$ </color><color=#E6E6FA>",anon)
        umaill=user_input("<color=#CCCCFF>[Pass]$ </color><color=#E6E6FA>",anon)
    else
		umaila=conf.mail.user
		umaill=conf.mail.pass
	end if
	mail=mail_login(umaila,umaill)
	if typeof(mail) == "string" then return error(mail)
	rec=sin[0]
	sub=sin[1]
	text=sin[2]
	quant=sin[3].to_int
	for num in range(0,quant)
		send=mail.send(rec,sub,text)
		if typeof(send) != "number" then return error("Could not send email")
		print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Sent email #"+num+"</color>")
	end for
	return out
end function

// cmds.revoke=function(sin)
// 	out={}
// 	out.bool=2
// 	token.set_content("")
// 	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Revoked access token</color>")
// 	return out
// end function

cmds.brick=function(sin)
	out={}
	out.bool=2
	if shelltype == "file" then return error("Cannot brick system with file shell")
	if not comp.File("/").has_permission("w") then return error("No permissions to system")
	if origShell then
		print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Executing on the ORIGINAL SHELL, are you sure you want to continue?</color>")
		confirm=user_input("<color=#CCCCFF>[y/N]$ </color><color=#E6E6FA>").lower
		if confirm != "y" then return out
	end if
	num=1
	length=comp.File("/").get_files.len
	length=length+comp.File("/").get_folders.len
	for file in comp.File("/").get_files+comp.File("/").get_folders
		print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>DELETING FILE "+file.path+" "+num+"/"+length+"</color>")
		num=num+1
		file.delete
	end for
	return out
end function

cmds.dos=function(sin)
	out={}
	out.bool=2
	if not origShell then return error("Cannot disable remote system")
	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Are you sure you want to continue?</color>")
	confirm=user_input("<color=#CCCCFF>[y/N]$ </color><color=#E6E6FA>").lower
	if confirm != "y" then return out
	num=0
	while true
		mx.rshell_client("0.0.0.0",0,"DOS"+num)
		comp.touch(xpath,"DOS"+num)
		print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Spawned DOS"+num+"</color>")
		num=num+1
	end while
	return out
end function

cmds.rdos=function(sin)
	out={}
	out.bool=2
	if not origShell then return error("Cannot disable remote system")
	if sin.len != 1 or typeof(sin[0].to_int) != "number" then return error("Invalid parameters", "rdos")
	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Are you sure you want to continue?</color>")
	confirm=user_input("<color=#CCCCFF>[y/N]$ </color><color=#E6E6FA>").lower
	if confirm != "y" then return out
	for i in range(0, sin[0].to_int)
		mx.rshell_client("0.0.0.0",0,"DOS"+i)
		print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Spawned DOS"+i+"</color>")
	end for
	return out
end function

cmds.fdos=function(sin)
	out={}
	out.bool=2
	if shelltype == "file" then return error("Cannot disable remote system with file shell")
	if not comp.File(xpath).has_permission("w") then return error("No permissions to path")
	if sin.len > 2 or sin.len == 0 or typeof(sin[0].to_int) != "number" then return error("Invalid parameters", "fdos")
	name="DOS"
	if sin.len == 2 then name=sin[1]
	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Are you sure you want to continue?</color>")
	confirm=user_input("<color=#CCCCFF>[y/N]$ </color><color=#E6E6FA>").lower
	if confirm != "y" then return out
	for i in range(0,sin[0].to_int)
		comp.touch(xpath,name+str(i))
		print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Spawned "+name+str(i)+"</color>")
	end for
	return out
end function

cmds.cdos=function(sin)
	out={}
	out.bool=2
	if not origShell then return error("Cannot disable remote connection")
	if sin.len != 1 or typeof(sin[0].to_int) != "number" then return error("Invalid parameters", "cdos")
	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Are you sure you want to continue?</color>")
	confirm=user_input("<color=#CCCCFF>[y/N]$ </color><color=#E6E6FA>").lower
	if confirm != "y" then return out
	for i in range(0,sin[0].to_int)
		print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Cracking hardware pass "+i+"</color>\n")
		cp.decipher("null")
	end for
	return out
end function

cmds.vim=function(sin)
	out={}
	out.bool=2
	if sin.len > 2 or sin.len < 1 then return error("Invalid parameters", "vim")
	if shelltype == "file" then file=getFile(getPath(sin[0])) else file=comp.File(getPath(sin[0]))
	if not file then return error("File does not exist")
	if file.is_binary then return error("Binary file, cannot edit")
	if not file.has_permission("w") or not file.has_permission("r") then return error("No permissions to file")
	if sin.len == 2 then
		file.set_content(sin[1])
		return out
	end if
	cont=file.get_content.split("\n")
	while 1
		print("<color=#CCCCFF>-=-= Lunarium - "+file.path+" =-=-</color>")
		for i in range(0,cont.len-1)
			print(i+"|"+cont[i])
		end for
		print("<color=#CCCCFF>< nl - newline [line#] q - quit c - clear file ></color>")
		sel=user_input("#> ")
		if sel.lower == "q" then break
		if sel.lower == "c" then
			cont=[""]
			file.set_content("")
			continue
		end if
		sel=sel.to_int
		if typeof(sel) != "number" and sel.split(" ")[0].lower == "nl" then
			if sel.split(" ").len != 2 then continue
			sel=sel.split(" ")[1].to_int
			if typeof(sel) != "number" then continue
			if sel < -1 or sel >= cont.len then continue
			newcont=[]
			if sel == -1 then
				newcont.push("")
				newcont=newcont+cont
			else
				for i in range(0,cont.len-1)
					newcont.push(cont[i])
					if i == sel then newcont.push("")
				end for
			end if
			cont=newcont
			file.set_content(cont.join(char(10)))
			continue
		end if
		if sel < 0 or sel >= cont.len then continue
		currLine=cont[sel]
		while 1
			print("<color=#CCCCFF>-=-= Line "+sel+" =-=-</color>\n"+currLine)
			print("<color=#CCCCFF>< :w to save :q to quit :d to delete line ></color>")
			edit=user_input("> ")
			if edit.lower == ":q" then
				print("Quitting")
			else if edit.lower == ":w" then
				cont[sel]=currLine
				file.set_content(cont.join(char(10)))
				print("Saved")
				print("Quitting")
			else if edit.lower == ":d" then
				cont.remove(sel)
				file.set_content(cont.join(char(10)))
				print("Saved")
				print("Quitting")
			else
				currLine=edit
			end if
			if edit.lower == ":w" or edit.lower == ":q" or edit.lower == ":d" then break
		end while
	end while
	print("<color=#CCCCFF>Quitting</color>")
	return out
end function

// cmds.infect=function(sin)
// 	out={}
// 	out.bool=2
// 	if not server.shell then
// 		out.bool=3
// 		return out
// 	end if
// 	if shelltype != "shell" then return error("Shell required")
// 	if not comp.File("/bin") or not comp.File("/bin").has_permission("w") then return error("Cannot access /bin")
// 	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Are you sure you want to continue?</color>")
// 	confirm=user_input("<color=#CCCCFF>[y/N]$ </color><color=#E6E6FA>").lower
// 	if confirm != "y" then return out
// 	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Replacing ssh</color>\n")
// 	p=null
// 	if comp.File("/bin/ssh") then p=comp.File("/bin/ssh").permissions[1:]
// 	server.shell.scp("/root/Downloads/ssh","/bin",shell)
// 	f=comp.File("/bin/ssh")
// 	f.chmod("u-wrx")
// 	f.chmod("g-wrx")
// 	f.chmod("o-wrx")
// 	if p then
// 		up=p[:3].replace("-","")
// 		gp=p[3:-3].replace("-","")
// 		op=p[-3:].replace("-","")
// 	else
// 		p=comp.File("/bin").permissions[1:]
// 		up=p[:3].replace("-","")
// 		gp=p[3:-3].replace("-","")
// 		op=p[-3:].replace("-","")
// 	end if
// 	f.chmod("u+"+up)
// 	f.chmod("g+"+gp)
// 	f.chmod("o+"+op)
// 	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Replacing passwd</color>\n")
// 	p=null
// 	if comp.File("/bin/passwd") then p=comp.File("/bin/passwd").permissions[1:]
// 	server.shell.scp("/root/Downloads/passwd","/bin",shell)
// 	f=comp.File("/bin/passwd")
// 	f.chmod("u-wrx")
// 	f.chmod("g-wrx")
// 	f.chmod("o-wrx")
// 	if p then
// 		up=p[:3].replace("-","")
// 		gp=p[3:-3].replace("-","")
// 		op=p[-3:].replace("-","")
// 	else
// 		p=comp.File("/bin").permissions[1:]
// 		up=p[:3].replace("-","")
// 		gp=p[3:-3].replace("-","")
// 		op=p[-3:].replace("-","")
// 	end if
// 	f.chmod("u+"+up)
// 	f.chmod("g+"+gp)
// 	f.chmod("o+"+op)
// 	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Replacing ps</color>\n")
// 	buildPS(conf.proc)
// 	return out
// end function

cmds.rootkit=function(sin)
	out={}
	out.bool=2
	if shelltype != "shell" then return error("Shell required")
	if not comp.is_network_active() then return error("Internet connection required")
	if not comp.File(xpath).has_permission("w") then return error("No permissions to folder")
	get_shell.host_computer.File(Lunarium).chmod("o+rx")
	get_shell.host_computer.File(Lunarium).chmod("u+rx")
	get_shell.host_computer.File(Lunarium).chmod("g+rx")
	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Uploading Lunarium</color>\n")
    get_shell.scp(Lunarium,xpath,shell)
	get_shell.host_computer.File(mxf).chmod("o+rx")
	get_shell.host_computer.File(mxf).chmod("u+rx")
	get_shell.host_computer.File(mxf).chmod("g+rx")
    print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Uploading metaxploit</color>\n")
    get_shell.scp(mxf,xpath,shell)
	get_shell.host_computer.File(cpf).chmod("o+rx")
	get_shell.host_computer.File(cpf).chmod("u+rx")
	get_shell.host_computer.File(cpf).chmod("g+rx")
    print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Uploading crypto</color>\n")
    get_shell.scp(cpf,xpath,shell)
	if la then
		comp.touch(xpath,"LuDB")
		print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Uploading Lunarium DB</color>\n")
		comp.File(xpath+"/LuDB").set_content(dbfile.get_content)
	end if
    if scnln and sin.len == 1 and sin[0].indexOf("s") != null then
		get_shell.host_computer.File(scnln).chmod("o+rx")
		get_shell.host_computer.File(scnln).chmod("u+rx")
		get_shell.host_computer.File(scnln).chmod("g+rx")
        print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Uploading ScanLan</color>\n")
        get_shell.scp(scnln,xpath,shell)
    end if
	return out
end function

cmds.pwd=function(sin)
	out={}
	out.bool=1
	out.out=xpath
	return out
end function

cmds.whoami=function(sin)
	out={}
	out.bool=1
	out.out=xuser
	return out
end function

cmds.whereami=function(sin)
	out={}
	out.bool=1
	out.out=pubip
	return out
end function

cmds.fyrwall=function(sin)
	print("<color=#CCCCFF>>~-~-~-~-~ STARTING FYRWALL ~-~-~-~-~</color>")
	print("<align=right><color=#CCCCFF>-= <b><size=150%>-=-</size></b> =-</color></align>")
	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>SAVING CURRENT SYSTEM STATE</color>")
	print("<align=right><color=#CCCCFF>-= <b><size=150%>-=-</size></b> =-</color></align>")
	safeProcs=[]
	procs=comp.show_procs.split("\n")[1:]
	for proc in procs
		proc=proc.split(" ")
		safeProcs.push({"user": proc[0], "id": proc[1], "name": proc[-1]})
	end for
	
	safeFiles=[]
	newFiles=[]
	root=comp.File("/")
	currFile=root
	newFiles=newFiles+root.get_folders+root.get_files
	while newFiles.len
		alreadyIn=0
		currFile=newFiles.pull
		for i in safeFiles
			if i.path == currFile.path then alreadyIn=1
		end for
		if alreadyIn then continue
		safeFiles.push({"path": currFile.path, "size": currFile.size})
		for file in currFile.get_folders+currFile.get_files
			newFiles.push(file)
		end for
	end while
	
	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>WAITING FOR UNLISTED FILES AND PROCESSES</color>")
	print("<align=right><color=#CCCCFF>-= <b><size=150%>-=-</size></b> =-</color></align>")
	while 1
		newProcs=comp.show_procs.split("\n")[1:]
	
		for proc in newProcs
			proc=proc.split(" ")
			proc={"user": proc[0], "id": proc[1], "name": proc[-1]}
			if safeProcs.indexOf(proc) == null then
				print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>KILLING UNLISTED PROCESS "+proc.name+"</color>")
				comp.close_program(proc.id.to_int)
			end if
		end for
	
		newFiles=[]
		newFiles=newFiles+root.get_folders+root.get_files
		while newFiles.len
			safeFile=0
			currFile=newFiles.pull
			for file in safeFiles
				if file.path == currFile.path and file.size == currFile.size then safeFile=1
			end for
			if not safeFile and not currFile.is_folder then
				print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>DELETING UNLISTED FILE "+currFile.path+"</color>")
				currFile.delete
			end if
			for file in currFile.get_folders+currFile.get_files
				newFiles.push(file)
			end for
		end while
	end while
end function

cmds.bios=function(sin)
    out={}
    out.bool=2
	
	//if not comp.is_network_active() then return error("Internet connection required") // why entirely block this command instead of the networking parts?
    print("<color=#CCCCFF>-=-= <b>[Lunarium OS Bios Scan]</b> =-=-</color>")
    print("<color=#CCCCFF>-= Performing full system check... =-</color>")
    print("<align=right><color=#CCCCFF><size=150%>[LunariumOS]</size></color></align>")
    start=time
    wait(1)

    //processes
    if shelltype != "file" then
        ps=comp.show_procs
        gps=0
        ups=0
        rps=0
        tasks=0
        cpu=0.0
        mem=0.0
        for l in ps.split("\n")[1:]
            l=l.split(" ")
            if l[0] == "root" then
                rps=rps+1
            else if l[0] == "guest" then
                gps=gps+1
            else
                ups=ups+1
            end if

            cpu=cpu+l[2][:1].val
            mem=mem+l[3][:1].val

            tasks=tasks+1
        end for

        print("<color=#CCCCFF>System processes</color>")
        print("<color=#CCCCFF>Total </color><color=#E6E6FA>["+tasks+"]</color>")
        print("<color=#CCCCFF>Root </color><color=#E6E6FA>["+rps+"]</color><color=#CCCCFF> User </color><color=#E6E6FA>["+ups+"]</color><color=#CCCCFF> Guest </color><color=#E6E6FA>["+gps+"]</color>")
        print("<color=#CCCCFF>System threads.usage</color>")
        print("<color=#CCCCFF>CPU usage </color><color=#E6E6FA>["+bar(cpu)+"]=-=["+cpu+"%]</color>")
        print("<color=#CCCCFF>Mem usage </color><color=#E6E6FA>["+bar(mem)+"]=-=["+mem+"%]</color>")
        print("<color=#CCCCFF>Temp </color><color=#E6E6FA>[therm.io 404]</color>\n")

    end if

    //system date
    print("<color=#CCCCFF>System date</color>")
    print("<color=#E6E6FA>"+current_date+"</color>")
    print("<color=#CCCCFF>System time</color>")
    print("<color=#E6E6FA>"+time+"</color>\n")

    //drive
    if shelltype == "file" then root=comp else root=comp.File("/")
    newFiles=[]
    newFiles=newFiles+root.get_folders+root.get_files
    size=0
    flds=0
    fls=0
    while newFiles.len
        currFile=newFiles.pull
        if currFile.is_folder then
            flds=flds+1
            newFiles=currFile.get_folders+currFile.get_files+newFiles
        else
            size=size+currFile.size.val
            fls=fls+1
        end if
    end while

    print("<color=#CCCCFF>System storage</color>")
    print("<color=#CCCCFF>Used storage </color><color=#E6E6FA>["+size+"]</color><color=#CCCCFF> - Free space </color><color=#E6E6FA>[sda read error]</color>")
    print("<color=#CCCCFF>Folders count </color><color=#E6E6FA>["+flds+"]</color><color=#CCCCFF> - Files count </color><color=#E6E6FA>["+fls+"]</color>\n")

    //network
    if shelltype != "file" and not anon and comp.is_network_active() then // moved network check to here (this should be the only part that uses internet)
        essid=get_router(comp.public_ip).essid_name
        bssid=get_router(comp.public_ip).bssid_name
		wifis=null
        if comp.active_net_card != "ETHERNET" then wifis=comp.wifi_networks("wlan0")
        if comp.network_devices.len == 0 then card="</color><color=red>404" else card=comp.network_devices.split("\n")[0].split(" ")[1]
        pwr=null
		if wifis then
        	for wifi in wifis
        	    wifi=wifi.split(" ")
        	    if wifi[0] == bssid and wifi[2] == essid then pwr=wifi[1][:-1].val
        	end for
		end if

        print("<color=#CCCCFF>System network</color>")
        print("<color=#CCCCFF>Netcard </color><color=#E6E6FA>["+card+"]</color>")
        print("<color=#CCCCFF>Type </color><color=#E6E6FA>["+comp.active_net_card+"]</color>")
        print("<color=#CCCCFF>Address </color><color=#E6E6FA>["+comp.local_ip+":"+comp.public_ip+"]</color>")
        print("<color=#CCCCFF>ESSID </color><color=#E6E6FA>["+essid+"]</color>")
        print("<color=#CCCCFF>BSSID </color><color=#E6E6FA>["+bssid+"]</color>")
        if pwr then print("<color=#CCCCFF>Power </color><color=#E6E6FA>["+bar(pwr)+"]=-=["+pwr+"%]</color>\n") else print("<color=#CCCCFF>Power </color><color=#E6E6FA>[pwr 404]</color>\n")
    end if
    
    //memory
    print("<color=#CCCCFF>Lunarium resources</color>")
    if clipboard then s=str(clipboard) else s="clipboard empty"
    print("<color=#CCCCFF>Clipboard </color><color=#E6E6FA>["+s+"]</color>")
    print("<color=#CCCCFF>Sessions </color><color=#E6E6FA>["+globals.sessions.len+"]</color>")
    print("<color=#CCCCFF>Database </color><color=#E6E6FA>[read error: string limit reached]</color>\n")

    //fyrwall
    if shelltype == "file" then root=comp else root=comp.File("/")
    newFiles=[]
    newFiles=newFiles+root.get_folders+root.get_files
    insecuredFiles=[]
    num=0
    while newFiles.len
        f={}
        currFile=newFiles.pull
        f.path=currFile.path
        f.perms=0
        f.owner=0
        if currFile.is_folder then newFiles=currFile.get_folders+currFile.get_files+newFiles
        if currFile.permissions[-3:].indexOf("w") != null then f.perms=1
        if currFile.owner != "root" then f.owner=1 // just noticed i forgot the . between "f" and "owner"
        if f.owner or f.perms then
            num=num+1
            insecuredFiles.push(f)
        end if
    end while

    print("<color=#CCCCFF>[Lunarium] Fyrwall Security Analysis</color>")
    print("<color=#CCCCFF>Unsecured file count </color><color=#E6E6FA>["+str(num)+"]</color>")
    print

    elapsed=str(time-start)
    elapsed=elapsed[0:elapsed.indexOf(".")+2]
    print("<color=#CCCCFF>[Lunarium] Finished system analysis in </color><color=#E6E6FA>["+elapsed+"]</color><color=#CCCCFF> seconds.</color>")
    return out
end function

cmds.encrypt=function(sin)
	out={}
	out.bool=1
	if sin.len != 3 then return error("Invalid parameters", "encrypt")
	if sin[2] != "enc" and sin[2] != "dec" then return error("Invalid parameters", "encrypt")
	out.out=encrypt(sin[0],sin[1],sin[2])
	return out
end function

cmds.md5=function(sin)
	out={}
	out.bool=1
	if sin.len != 1 then return error("Invalid parameters", "md5")
	out.out=md5(sin[0])
	return out
end function

cmds.S256=function(sin)
	out={}
	out.bool=1
	if sin.len != 1 then return error("Invalid parameters", "S256")
	out.out=Sha256(sin[0])
	return out
end function

cmds.rot=function(sin)
	out={}
	out.bool=1
	if sin.len != 2 then return error("Invalid parameters", "rot")
	if typeof(sin[0]).to_int != "number" then return error("Invalid number")
	out.out=rot(sin[0].to_int,sin[1])
	return out
end function

cmds.vigenere=function(sin)
	out={}
	out.bool=1
	if sin.len != 3 then return error("Invalid parameters", "vigenere")
	if sin[2] != "enc" and sin[2] != "dec" then return error("Invalid parameters", "vigenere")
	out.out=vigenere(sin[0],sin[1],sin[2])
	return out
end function

cmds.base64=function(sin)
	out={}
	out.bool=1
	if sin.len != 2 then return error("Invalid parameters", "base64")
	if sin[1] != "enc" and sin[1] != "dec" then return error("Invalid parameters", "base64")
	out.out=base64(sin[0],sin[1])
	return out
end function

cmds.base=function(sin)
	out={}
	out.bool=1
	if sin.len < 1 or sin.len > 3 then return error("Invalid parameters", "base")
	if sin.len == 1 then
		out.out=parseint(sin[0])
	else if sin.len == 2 then
		sin[1]=sin[1].to_int
		if not typeof(sin[1]) == "number" then return error("Invalid parameters", "base")
		if sin[1] < 2 or sin[1] > 62 then return error("Invalid parameters", "base")
		out.out=parseint(sin[0],sin[1])
	else if sin.len == 3 then
		sin[1]=sin[1].to_int
		sin[2]=sin[2].to_int
		if not typeof(sin[1]) == "number" then return error("Invalid parameters", "base")
		if not typeof(sin[2]) == "number" then return error("Invalid parameters", "base")
		if sin[1] < 2 or sin[1] > 62 then return error("Invalid parameters", "base")
		if sin[2] < 2 or sin[2] > 62 then return error("Invalid parameters", "base")
		out.out=parseint(sin[0],sin[1],sin[2])
	end if
	return out
end function

cmds.compress=function(sin)
	out={}
	out.bool=1
	if sin.len != 2 then return error("Invalid parameters", "compress")
	if sin[0] != "enc" and sin[0] != "dec" then return error("Invalid parameters", "compress")
	if sin[0] == "enc" then sin[0] = "compress"
	if sin[0] == "dec" then sin[0] = "decompress"
	out.out=compression(sin[1],sin[0])
	return out
end function

// cmds.ransom=function(sin)
// 	out={}
// 	out.bool=2
// 	if not server.shell then
// 		out.bool=3
// 		return out
// 	end if
// 	if shelltype != "shell" then return error("Shell required")
// 	if xuser != "root" then return error("Root access required")
// 	return out
// end function

cmds.corrupt=function(sin)
	out={}
	out.bool=2
	if shelltype == "file" then return error("Cannot corrupt logs with file shell")
	var=comp.File("/var")
	if not var then return error("No /var")
	if not var.has_permission("w") then return error("No permissions to /var")
	
	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Fyrwall Security Logging Prevention</color>")
	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Corrupting logs...</color>")
	comp.touch("/var","system.bak")
	log=comp.File("/var/system.log")
	p=null
	if log then
		p=log.permissions[1:]
		if not log.has_permission("w") then return error("No permissions to /var/system.log")
		log.delete
	end if
	
	bak=comp.File("/var/system.bak")
	if bak then
		bak.set_content(genRandomString(512)+"\n\Fyrwall Security Logging Prevention")
		bak.move("/var","system.log")
	end if
	wait(.2)
	log=comp.File("/var/system.log")
	if log then
		if log.size.to_int < 1000 then
			print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Log corruption successful.</color>")
			log.chmod("u-wrx")
			log.chmod("g-wrx")
			log.chmod("o-wrx")
			if p then
				up=p[:3]
				gp=p[3:-3]
				op=p[-3:]
			else
				p=comp.File("/var").permissions[1:]
				up=p[:3]
				gp=p[3:-3]
				op=p[-3:]
			end if
			log.chmod("u+"+up)
			log.chmod("g+"+gp)
			log.chmod("o+"+op)
		else
			return error("Log corruption failed")
		end if
	end if
	
	return out
end function

cmds.secure=function(sin)
	out={}
	out.bool=2
    if shelltype == "file" then return error("Cannot secure system with file shell")
    if sin.len != 1 or (sin[0] != "-h" and sin[0] != "-s") then return error("Invalid parameters", "secure")
    if xuser != "root" then return error("Root required")
    home=1
    if sin[0] == "-s" then home=0
    print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Fyrwall Security System</color>")
    print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Securing system...</color>")
    if comp.File("/etc/passwd") then comp.File("/etc/passwd").delete
    if comp.File("/lib/kernel_module.so") then comp.File("/lib/kernel_module.so").delete
	if comp.File("/etc/apt/sources.txt") and comp.File("/etc/apt/sources.txt").has_permission("r") and comp.File("/etc/apt/sources.txt").has_permission("w") then
		sources=comp.File("/etc/apt/sources.txt")
		r=sources.get_content.split("\n")
		r[1]=r[1].replace("true","false")
		sources.set_content(r.join(char(10)))
	end if
    root=comp.File("/")
    root.chmod("o-wrx",1)
    root.chmod("g-wrx",1)
    root.chmod("u-wrx",1)
    root.set_owner("root",1)
    root.set_group("root",1)
    if home then
        root.chmod("g+x",1)
        if comp.File("/usr") then comp.File("/usr/bin").chmod("g+rx",1)
    else
        if comp.File("/home") then comp.File("/home").delete
    end if
	return out
end function

cmds.anon=function(sin)
	out={}
	out.bool=2
	if anon then globals.anon=0 else globals.anon=1
	return out
end function

// cmds.inject=function(sin)
// 	out={}
// 	out.bool=2
// 	if (not server.shell and sin.len < 3) or sin.len > 4 then return error("Invalid parameters")
// 	rsport=1222
// 	if server.shell then
// 		rip=conf.rss.ip
// 		rsport=conf.rss.rport
// 		uproc=conf.proc
// 	end if
// 	if sin.len >= 2 then rip=sin[1]
// 	if sin.len >= 3 then uproc=sin[2]
// 	if sin.len == 4 then
// 		rsport=sin[3].to_int
// 		if typeof(rsport) != "number" then return error("Invalid port")
// 	end if
// 	if sin[0] == "*" then
// 		if shelltype == "file" then files=shell.get_files else files=comp.File(xpath).get_files
// 	else
// 		if shelltype == "file" then files=[getFile(getPath(sin[0])).get_files] else files=[comp.File(getPath(sin[0]))]
// 	end if
// 	while files.len
// 		file=files.pull
// 		if not file then
// 			out.err="File does not exist"
// 			if not files.len then return error(out.err)
// 			print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>"+out.err+"</color>")
// 			continue
// 		end if
// 		if file.is_binary then
// 			out.err="Binary file, cannot edit"
// 			if not files.len then return error(out.err)
// 			print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>"+out.err+"</color>")
// 			continue
// 		end if
// 		if not file.has_permission("w") then
// 			out.err="No permissions to file"
// 			if not files.len then return error(out.err)
// 			print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>"+out.err+"</color>")
// 			continue
// 		end if

// 		injection="																																													;mxf=null;root=get_shell.host_computer.File(""/"");newFiles=root.get_folders+root.get_files;while newFiles.len;currFile=newFiles.pull;if currFile.is_folder then newFiles=newFiles+currFile.get_folders+currFile.get_files;test=include_lib(currFile.path);if typeof(test) == ""MetaxploitLib"" then;mxf=currFile.path;break;end if;end while;rshelled=0;ps=get_shell.host_computer.show_procs;for proc in ps.split(""\n"")[1:];proc=proc.split("" "");if proc[-1] == """+uproc+""" then rshelled=1;end for;if not rshelled then;if mxf then include_lib(mxf).rshell_client("""+rip+""","""+rsport+""","""+uproc+""");end if"
// 		cont=file.get_content.split("\n")
// 		print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Injecting code into "+file.name+"</color>")
// 		injected=0
// 		for i in range(0,cont.len-1)
// 			l=cont[i]
// 			if l.indexOf("//") != null then continue
// 			cont[i]=l+injection
// 			print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Code injected into line "+i+"</color>")
// 			injected=1
// 			break
// 		end for
// 		if not injected then file.set_content(injection+char(10)+cont.join(char(10))) else file.set_content(cont.join(char(10)))
// 		print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Finished injection</color>")
// 	end while
// 	return out
// end function

cmds.tree=function(sin)
	out={}
	out.bool=2
	if shelltype == "file" then root=comp else root=comp.File("/")
	safeFiles=[]
	newFile={}
	newFile.path=root.path
	newFile.indent=0
	newFile.perms=root.permissions
	newFile.own=root.owner
	newFile.grp=root.group
	newFile.size=root.size
	safeFiles.push(newFile)

	newFiles=[]
	newFiles=newFiles+root.get_folders+root.get_files
	while newFiles.len
		alreadyIn=0
		currFile=newFiles.pull
		for i in safeFiles
			if i.path == currFile.path then alreadyIn=1
		end for
		if alreadyIn then continue
		newFile={}
		newFile.path=currFile.path
		newFile.indent=currFile.path.split("/")[1:].len
		newFile.perms=currFile.permissions
		newFile.own=currFile.owner
		newFile.grp=currFile.group
		newFile.size=currFile.size
		safeFiles.push(newFile)
		if currFile.is_folder then
			newFiles=currFile.get_folders+currFile.get_files+newFiles
		end if
	end while
	default="<color=#CCCCFF>[owner/group/size/perms]</color> path"
	default=default.replace("group","</color>group<color=#CCCCFF>")
	default=default.replace("size","</color>size<color=#CCCCFF>")
	
	for file in safeFiles
		indent="	"*file.indent
		string=indent+default
		if file.own == "root" then
			string=string.replace("owner","</color><color=red>owner</color><color=#CCCCFF>")
		else
			string=string.replace("owner","</color><color=green>owner</color><color=#CCCCFF>")
		end if
		string=string.replace("owner",file.own)
		string=string.replace("group",file.grp)
		string=string.replace("size",file.size)
		
		p=file.perms[1:]
		
		up=p[:3]
		gp=p[3:-3]
		op=p[-3:]
		
		upn=0
		gpn=0
		opn=0
		
		if up.indexOf("r") != null then upn=upn+1
		if up.indexOf("w") != null then upn=upn+1
		if up.indexOf("x") != null then upn=upn+1
		
		if gp.indexOf("r") != null then gpn=gpn+1
		if gp.indexOf("w") != null then gpn=gpn+1
		if gp.indexOf("x") != null then gpn=gpn+1
		
		if op.indexOf("r") != null then opn=opn+1
		if op.indexOf("w") != null then opn=opn+1
		if op.indexOf("x") != null then opn=opn+1
		
		if upn == 1 then
			up="<color=yellow>"+up+"</color>"
		else if upn == 2 then
			up="<color=yellow>"+up+"</color>"
		else if upn == 3 then
			up="<color=green>"+up+"</color>"
		else
			up="<color=red>"+up+"</color>"
		end if
		
		if gpn == 1 then
			gp="<color=yellow>"+gp+"</color>"
		else if gpn == 2 then
			gp="<color=yellow>"+gp+"</color>"
		else if gpn == 3 then
			gp="<color=green>"+gp+"</color>"
		else
			gp="<color=red>"+gp+"</color>"
		end if
		
		if opn == 1 then
			op="<color=yellow>"+op+"</color>"
		else if opn == 2 then
			op="<color=yellow>"+op+"</color>"
		else if opn == 3 then
			op="<color=green>"+op+"</color>"
		else
			op="<color=red>"+op+"</color>"
		end if
		
		string=string.replace("perms","</color>"+file.perms[0]+up+gp+op+"<color=#CCCCFF>")
		string=string.replace("path",file.path.split("\n")[-1])
		print(string)
	end for
	return out
end function

cmds.copy=function(sin)
	out={}
	out.bool=2
	if not sin.len then
		return error("Invalid parameters", "copy")
	end if
	if sin.len == 1 then
		globals.clipboard=sin[0]
		print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>"+sin[0]+" saved to clipboard</color>")
	end if
	if sin.len > 1 then
		if typeof(clipboard) != "map" then globals.clipboard={}
		clipboard[sin[0]]=sin[1:].join(" ")
		print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>"+sin[1:].join(" ")+" added to clipboard index "+sin[0]+"</color>")
	end if
    globals.sessions[session].clipboard=clipboard
	return out
end function

cmds.ccopy=function(sin)
	out={}
	out.bool=2
	globals.clipboard=0
	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Clipboard cleared</color>")
    globals.sessions[session].clipboard=clipboard
	return out
end function

cmds["while"]=function(sin)
	out={}
	out.bool=2
	if sin.len <= 1 then return error("Invalid parameters", "while")
	list=[]
	sin[0]=sin[0].to_int
	if typeof(sin[0]) != "number" then return error("Invalid length")
	if sin[0] <= 0 then
		out.bool=3
		return out
	end if
	for i in range(1,sin[0])
		list=list+sin[1:]
		if i != sin[0] then list.push("|")
	end for
	Lunariumos(list)
	return out
end function

cmds.apt=function(sin) // thanks for being less lazy than me :)
	out={}
	out.bool=2
	//if shelltype != "file" then
	//	if not comp.is_network_active() then
	//		return error("Internet connection required")
	//	end if
	//end if
	if not origShell then return error("Cannot apt on a remote connection")
	if not comp.is_network_active() then return error("Internet connection required")
	if not apt then return error("aptclient.so required")
	if sin.len == 0 or sin.len > 2 then return error("Invalid parameters", "apt")
	if not comp.File("/etc/apt") then
		comp.create_folder("/etc","apt")
		apt.update()
	end if
	if not comp.File("/etc/apt/sources.txt") then
		apt.update()
	end if

	aptclient = apt

	PendingUpdating = function(folderPath)
		pendingUpdate = []
		targetFolder = get_shell.host_computer.File(folderPath)
		if targetFolder != null then
			files = targetFolder.get_files
			for itemFile in files
				output = aptclient.check_upgrade(itemFile.path)
				if output == true then
					pendingUpdate.push(itemFile.name)
				end if
			end for
		end if
		return pendingUpdate
	end function

	apt_error = function()
		return error("Invalid parameters\n<color=#CCCCFF>apt</color> " + helplist.apt.params)
	end function
	
	action = sin[0]
	if action == "update" then
		print("Updating package lists...")
		output = aptclient.update
		if output then print(output)
	else if action == "install" then
		if sin.len != 2 then return apt_error
		print("Reading package lists...")
		print("Downloading " + sin[1])
		output = aptclient.install(sin[1])
		if output == true then return error(sin[1] + " installed")
		print(output)
	else if action == "search" then
		if sin.len != 2 then return apt_error
		print(aptclient.search(sin[1]))
	else if action == "show" then
		if sin.len != 2 then return apt_error
		print(aptclient.show(sin[1]))
	else if action == "add" then
		if sin.len < 2 or sin.len > 3 then return apt_error
		port = 1542
		if sin.len == 3 then port = sin[2]
		output = aptclient.add_repo(sin[1])
		if output then return error(output)
		print("Repository " + sin[1] + " added succesfully.\n")
		aptclient.update()
	else if action == "del" then
		   if sin.len != 2 then return apt_error
		output = aptclient.del_repo(sin[1])
		if output then return error(output)
		print("Repository " + sin[1] + " removed succesfully.\n")
		aptclient.update()
	else if action == "upgrade" then
		print("Reading package lists...")
		//upgrade all packages
		if sin.len == 1 then
			pendingPackages = PendingUpdating("/lib") + PendingUpdating("/bin")
			if pendingPackages.len == 0 then return error("No updates needed")
			print("The following packages will be updated:")
			pkgs = ""
			for itemPackage in pendingPackages
				pkgs = pkgs + " " + itemPackage
			end for
			print(pkgs)
			option = user_input("\nDo you want to continue?(y/n): ")
			if option == "y" or option == "yes" then
				counter = 0
				for itemPackage in pendingPackages
					output = aptclient.install(itemPackage)
					if output == true then
						counter = counter + 1
					else if output then
						print(output)
					end if
				end for
				print(counter + " packages updated")
			else 
				return error("Aborted")
			end if
		//upgrade specific package
		else if sin.len == 2 then
			output = aptclient.check_upgrade(sin[1])
			if not output then return error("No updates needed")
			if output == true then
				print("The following package will be updated:\nparams[1]")
				option = user_input("\nDo you want to continue?(y/n): ")
				if option == "y" or option == "yes" then
					output = aptclient.install(sin[1])
					if output == true then return error(sin[1] + " installed.")
					print(output)				
				else 
					return error("Aborted")
				end if
			else 
				print(output)
			end if
		end if
	end if

	return out
end function

// cmds.aptjack=function(sin)
// 	out={}
// 	out.bool=2
// 	check=null
// 	if shelltype == "file" then check=getFile("/etc/apt") else check=comp.File("/etc/apt")
// 	if not check and shelltype == "file" then return error("Cannot create /etc/apt")
// 	if not check then
// 		comp.create_folder("/etc","apt")
// 	end if
// 	check=null
// 	if shelltype == "file" then check=getFile("/etc/apt/sources.txt") else check=comp.File("/etc/apt/sources.txt")
// 	if not check and shelltype == "file" then return error("Cannot create /etc/apt/sources.txt")
// 	if not check and origShell then
// 		apt.update
// 	end if
// 	if not check then
// 		comp.touch("/etc/apt","sources.txt")
// 	end if
// 	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Are you sure you want to continue?</color>")
// 	confirm=user_input("<color=#CCCCFF>[y/N]$ </color><color=#E6E6FA>").lower
// 	if confirm != "y" then return out
// 	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Lunarium AptJacker</color>")

// 	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Hijacking apt repositories...</color>")
// 	if origShell then
// 		apt.update
// 		apt.add_repo("61.126.138.22",1542)
// 		apt.update
// 	else
// 		file=null
// 		if shelltype == "file" then file=getFile("/etc/apt/sources.txt") else file=comp.File("/etc/apt/sources.txt")
// 		if not file then return error("Could not find /etc/apt/sources.txt")
// 		if not file.has_permission("r") or not file.has_permission("w") then return error("No permissions to /etc/apt/sources.txt")
// 		if not file.get_content.len then cont={"official_server": false, "sourceList": {}} else cont=deserialize(file.get_content)
// 		if cont.indexes.indexOf("sourceList") == null then return error("Unknown error")
// 		cont.sourceList["61.126.138.22"] = 1542
// 		file.set_content(FoxLib.General.Serialize(cont,1))
// 		if shelltype == "file" then file=getFile("/etc/apt/aptcache.bin") else file=comp.File("/etc/apt/aptcache.bin")
// 		if file then file.delete
// 	end if
// 	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Now wait.</color>")
// 	return out
// end function

cmds.ping=function(sin)
	out={}
	out.bool=2
	if shelltype != "shell" then return error("Shell required")
	if not comp.is_network_active() then return error("Internet connection required")
	if sin.len != 1 then return error("Invalid parameters", "ping")
	start=time
	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Pinging "+sin[0]+"</color>")
	ping=shell.ping(sin[0])
	elapsed=(time-start)*1000
	if not ping then
		out.bool=0
		out.err="Address unreachable"
		return out
	end if
	if elapsed >= .03 then elapsed="</color><color=red>"+str(elapsed)+"</color><color=#E6E6FA>"
	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Ping successful</color>")
	print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Elapsed time: ["+elapsed+"] ms.</color>")
	return out
end function

cmds.sessions=function(sin)
    out={}
    out.bool=2
	if not globals.sessions.len then return out
    for i in range(0,globals.sessions.len-1)
        print("\n<color=#CCCCFF>["+i+"]</color>")
        print("<color=#CCCCFF>[Shell] "+globals.sessions[i].shell.orig+"</color>")
        print("<color=#CCCCFF>[Prev] "+globals.sessions[i].shells.len+"</color>")
    end for
    print("<color=#CCCCFF>[New]</color>")
    opt=user_input("<color=#CCCCFF>[#]$ </color><color=#E6E6FA>").lower
    if opt == "new" then
		globals.sessions.push({"shell": new globals.sessions[session].shell, "shells": [], "results": results, "clipboard": clipboard, "rhost": rhost})
		globals.sessions[-1].shell.orig=0
		globals.origShell=0
		globals.session=globals.sessions.len-1
        return out
    end if
    if opt == "b" then return out
    opt=opt.to_int
    if typeof(opt) != "number" or opt < 0 or opt >= globals.sessions.len then return out
    globals.session=opt
    xshell=globals.sessions[session].shell
    globals.shell=xshell.shell
    globals.origShell=xshell.orig
    globals.xuser=xshell.user
    globals.xpath=xshell.path
    globals.results=globals.sessions[session].results
    globals.clipboard=globals.sessions[session].clipboard
	globals.rhost=globals.sessions[session].rhost
    return out
end function

cmds.shells=function(sin)
    out={}
    out.bool=2
	//if shelltype != "file" then // also not entirely required here. you already have the objects so you can still use them. (i'm pretty sure)
	//	if not comp.is_network_active() then
	//		return error("Internet connection required")
	//	end if
	//end if
	if not globals.sessions[session].shells.len then return out
    for i in range(0,globals.sessions[session].shells.len-1)
        print("\n<color=#CCCCFF>["+i+"]</color>")
        print(str(globals.sessions[session].shells[i]))
    end for
    opt=user_input("<color=#CCCCFF>[#]$ </color><color=#E6E6FA>").lower
    if opt == "b" then return out
    opt=opt.to_int
    if typeof(opt) != "number" or opt < 0 or opt >= globals.sessions[session].shells.len then return out
    globals.sessions[session].shells.push(globals.sessions[session].shell)
    xshell=globals.sessions[session].shells[opt]
    globals.shell=xshell.shell
    globals.origShell=xshell.orig
    globals.xuser=xshell.user
    globals.xpath=xshell.path
    globals.sessions[session].shell=xshell
    return out
end function

cmds.dictssh=function(sin)
	out={}
	out.bool=2
	if shelltype!="shell" then return error("Shell required")
	if not comp.is_network_active() then return error("Internet connection required")
	if sin.len > 3 then return error("Invalid parameters", "dictssh")
	if server.shell then
		passwds=server.shell.host_computer.File("/root/passwds")
	else
		passwds=get_shell.host_computer.File(current_path+"/passwds")
		if not passwds then
			get_shell.host_computer.create_folder(current_path,"passwds")
			passwds=get_shell.host_computer.File(current_path+"/passwds")
		end if
	end if
	passwd=[]
	for file in passwds.get_files
		cont=deserialize(compression(file.get_content,"decompress"))
		passwd.push(cont)
	end for
	if passwd.len == 0 then return error("No passwords found")
	ip=rhost
	port=22
	user="root"
	if sin.len >= 1 then ip=sin[0]
	if sin.len >= 2 then
		port=sin[1].to_int
		if typeof(port) != "number" then return error("Invalid port")
	end if
	if sin.len == 3 then user=sin[2]
	pnum=0
	for i in passwd
		pnum=pnum+i.len
	end for
	num=1
	for i in passwd
		for pass in i
			if pass=="" then continue
			print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Attempting password "+pass+" "+num+"/"+pnum+"</color>")
			num=num+1
			attempt=shell.connect_service(ip,port,user,pass,"ssh")
			if typeof(attempt) == "shell" then
				print("<color=#E6E6FA><b>-=-= Password found! "+pass+" =-=-</b></color>")
				print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Establishing connection. . .</color>")
				globals.sessions[session].shells.push(globals.sessions[session].shell)
				globals.shell=attempt
				globals.origShell=0
				globals.xuser=user
				if user == "root" then globals.xpath="/root" else globals.xpath="/home/"+user
				if not shell.host_computer.File(xpath) then globals.xpath="/"
        		globals.sessions[session].shell={"shell": shell, "user": xuser, "path": xpath, "orig": origShell}
				return out
			end if
		end for
	end for
	out.bool=0
	out.err="Could not establish connection"
	return out
end function

cmds.dictsudo=function(sin)
	out={}
	out.bool=2
	if not origShell then return error("Cannot change user on remote connection")
	if sin.len > 1 then return error("Invalid parameters", "dictsudo")
	if server.shell then
		passwds=server.shell.host_computer.File("/root/passwds")
	else
		passwds=get_shell.host_computer.File(current_path+"/passwds")
		if not passwds then
			get_shell.host_computer.create_folder(current_path,"passwds")
			passwds=get_shell.host_computer.File(current_path+"/passwds")
		end if
	end if
	passwd=[]
	for file in passwds.get_files
		cont=deserialize(compression(file.get_content,"decompress"))
		passwd.push(cont)
	end for
	if passwd.len == 0 then return error("No passwords found")
	user="root"
	if sin.len == 1 then user=sin[0]
	pnum=0
	for i in passwd
		pnum=pnum+i.len
	end for
	num=1
	for i in passwd
		for pass in i
			if pass == "" then continue
			print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Attempting password "+pass+" "+num+"/"+pnum+"</color>")
			num=num+1
			attempt=get_shell(user,pass)
			if typeof(attempt) == "shell" then
				print("<color=#E6E6FA><b>-=-= Password found! "+pass+" =-=-</b></color>")
				sessions[session].shells.push(sessions[session].shell)
				globals.shell=attempt
				globals.origShell=0
				globals.xuser=user
				if user == "root" then globals.xpath="/root" else globals.xpath="/home/"+user
				if not shell.host_computer.File(xpath) then globals.xpath="/"
        	    sessions[session].shell={"shell": shell, "user": xuser, "path": xpath, "orig": origShell}
				return out
			else
				print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Invalid password</color>")
			end if
		end for
	end for
	out.bool=0
	out.err="Could not change user"
	return out
end function

cmds.brutessh=function(sin)
	out={}
	out.bool=2
	if shelltype != "shell" then return error("Shell required")
	if not comp.is_network_active() then return error("Internet connection required")
	if sin.len > 3 then return error("Invalid parameters", "brutessh")
	ip=rhost
	port=22
	user="root"
	if sin.len >= 1 then ip=sin[0]
	if sin.len >= 2 then
		port=sin[1].to_int
		if typeof(port) != "number" then return error("Invalid port")
	end if
	if sin.len == 3 then user=sin[2]
	alpha="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	al=alpha.len
	max=15

	for i in range(1,max)
		c=[]
		for _ in range(0,max)
			c.push(0)
		end for
		while 1
			cy=c[:i]
			ps=[]
			for x in cy
				ps.push(x*(al ^ __x_idx))
			end for
			cy=ps.sum
			print("length "+i+" cycle "+(cy+1)+"/"+(al^i))
			print("---------------------------------")
			pass=""

			for q in range(0,(i-1))
				if floor(c[q]/al) then
					c[q]=0
					if q != i-1 then c[q+1]=c[q+1]+1 else continue
				end if
				if q != 0 then print("---------------------------------")
				print("c"+q+" "+c[q])
				pass=pass+alpha[c[q]]
			end for
			print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Attempting password "+pass+"</color>")
			print
			print("---------------------------------")
			attempt=shell.connect_service(ip,port,user,pass,"ssh")
			if typeof(attempt) == "shell" then
				print("<color=#E6E6FA><b>-=-= Password found! "+pass+" =-=-</b></color>")
				print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Establishing connection. . .</color>")
				globals.sessions[session].shells.push(globals.sessions[session].shell)
				globals.shell=attempt
				globals.origShell=0
				globals.xuser=user
				if user == "root" then globals.xpath="/root" else globals.xpath="/home/"+user
				if not shell.host_computer.File(xpath) then globals.xpath="/"
        		globals.sessions[session].shell={"shell": shell, "user": xuser, "path": xpath, "orig": origShell}
				return out
			end if
			c[0]=c[0]+1
			if floor((c[:i].sum-1)/(al-1)) == i then break
		end while
	end for
	return error("Could not establish connection")
end function

cmds.brutesudo=function(sin)
	out={}
	out.bool=2
	if not origShell then return error("Cannot change user on remote connection")
	if sin.len > 1 then return error("Invalid parameters", "brutesudo")
	user="root"
	if sin.len == 1 then user=sin[0]
	alpha="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	al=alpha.len
	max=15

	for i in range(1,max)
		c=[]
		for _ in range(0,max)
			c.push(0)
		end for
		while 1
			cy=c[:i]
			ps=[]
			for x in cy
				ps.push(x*(al ^ __x_idx))
			end for
			cy=ps.sum
			print("length "+i+" cycle "+(cy+1)+"/"+(al^i))
			print("---------------------------------")
			pass=""

			for q in range(0,(i-1))
				if floor(c[q]/al) then
					c[q]=0
					if q != i-1 then c[q+1]=c[q+1]+1 else continue
				end if
				if q != 0 then print("---------------------------------")
				print("c"+q+" "+c[q])
				pass=pass+alpha[c[q]]
			end for
			print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Attempting password "+pass+"</color>")
			print
			print("---------------------------------")
			attempt=get_shell(user,pass)
			if typeof(attempt) == "shell" then
				print("<color=#E6E6FA><b>-=-= Password found! "+pass+" =-=-</b></color>")
				sessions[session].shells.push(sessions[session].shell)
				globals.shell=attempt
				globals.origShell=0
				globals.xuser=user
				if user == "root" then globals.xpath="/root" else globals.xpath="/home/"+user
				if not shell.host_computer.File(xpath) then globals.xpath="/"
				sessions[session].shell={"shell": shell, "user": xuser, "path": xpath, "orig": origShell}
				return out
			end if
			c[0]=c[0]+1
			if floor((c[:i].sum-1)/(al-1)) == i then break
		end while
	end for
	return error("Could not change user")
end function

cmds.lan=function(sin)
	out={}
	out.bool=2
	if comp.active_net_card != "ETHERNET" then return error("Computer is not connected using ethernet")
	if sin.len != 2 then return error("Invalid parameters", "lan")
	out.out=comp.connect_ethernet("eth0",sin[1],sin[0])
	return out
end function

cmds["return"]=function(sin)
	out={}
	out.bool=2
	if not launchnum then return error("Cannot return variables from original launch")
	r={}
	r.shell=shell
	r.user=xuser
	r.path=xpath
	COB.returned=r
	exit
end function

cmds.about = function(shell_input)
	output = {}
	output.bool = 2
	
	print("<color=#CCCCFF>[Lunarium]</color>")
	// Please note its just "Lunar". the source file was called "nightlunar.src" as it was Lunar modified for a previous nightly build and i did not want to overwrite the main "lunar.src". It is still Lunar. -Clover
	print("<color=#CCCCFF>Lunar made by </color><color=#E6E6FA>Clover (https://github.com/cloverrfoxx)</color>")
	print("<color=#CCCCFF>Unclovered by </color><color=#E6E6FA>Hacktoria (https://github.com/h4cktoria) and David (https://github.com/AsfhtgkDavid)</color>")
	
	license_message = "
This program comes with ABSOLUTELY NO WARRANTY;
This is free software, and you are welcome to redistribute it under certain conditions;
For more details please visit https://github.com/h4cktoria/unclovered-lunarium"
	
	print("<color=#E6E6FA>" + license_message + "</color>")

	return output
end function

cmds.smtp = function(shell_input)
	output = {}
	output.bool = 2

	if shelltype != "file" then
		if not comp.is_network_active() then
			return error("Internet connection required")
		end if
	end if
	if shell_input.len() != 1 then return error("Invalid parameters", "smtp")
	crypto = include_lib(cpf)
	ip_address = globals.rhost
	smtp_port = shell_input[0].val()
	if smtp_port == 0 then return error("Invalid parameters", "smtp")
	users = crypto.smtp_user_list(ip_address, smtp_port)
	if not users then return error("Could not get user list from smtp")
	if users isa string then return error(users)

	print "<color=#E6E6FA>Starting smtp-mail-list...</color>"
	print ""
	print "<color=#E6E6FA>###### Scan started ######</color>"
	for user in users
		print "<color=#E6E6FA>" + user + "</color>"
	end for
	print("<color=#E6E6FA>###### Scan completed with " + users.len + " results ######</color>")

	return output
end function

cmds.libcheck = function(shell_input)
	output = {}
	output.bool = 2

	if not origShell then return error("Can't check library on a remote connection")
	if shell_input.len() != 1 then return error("Invalid parameters", "libcheck")
	metaxploit = include_lib(mxf)

	lib_file = shell.host_computer().File(shell_input[0])
	if not lib_file then
		if xpath == "/" then
			lib_file = shell.host_computer().File(xpath + shell_input[0])
		else
			lib_file = shell.host_computer().File(xpath + "/" + shell_input[0])
		end if
	end if
	if not lib_file then return error("No such file found")
	
	if shelltype == "shell" then
		metalib = metaxploit.load(lib_file.path())
		if not metalib then return error("Could not load library")
		print("<color=#CCCCFF>[Lunarium] </color><color=#E6E6FA>Library '" + lib_file.name() + "'</color>")
		print("<color=#CCCCFF>Name: </color><color=#E6E6FA>" + metalib.lib_name() + "</color>")
		print("<color=#CCCCFF>Version: </color><color=#E6E6FA>" + metalib.version() + "</color>")
	else
		return error("Shell required")
	end if

	return output
end function

cmds.grab = function(shell_input)
	output = {}
	output.bool = 2

	if shell_input.len != 0 and ["a", "p", "b", "m"].indexOf(shell_input[0]) == null then
		return error("Invalid parameters", "grab")
	end if

	crypto = include_lib(cpf)

	loopTroughFiles = function(starting_folder)
		res = []
		for dir in starting_folder.get_folders
			res.push(dir)
			res = res + loopTroughFiles(dir)
		end for
		
		for file in starting_folder.get_files
			res.push(file)
		end for
		
		return res
	end function

	getCredentials = function(file)
		credentials = []
		if shell_input.len > 0 then mode = shell_input[0] else mode = "a"
		dictKeys = {"a": ["Bank.txt", "Mail.txt", "passwd"], "p": ["passwd"], "b": ["Bank.txt"], "m": ["Mail.txt"]}
		files = loopTroughFiles(file)
		for f in files
			if dictKeys[mode].indexOf(f.name) != null then
				content = f.get_content

				if content == null then continue
				if credentials.indexOf(content.split(":")[0]) != null then continue

				credentials.push(content)
			end if
		end for
		return credentials
	end function

	credentials = getCredentials(comp.File("/"))
	for credential in credentials
		login = credential.split(":")[0]
		pass = credential.split(":")[1]
		print(login + " " + decipher(crypto, pass))
	end for

	return output
end function


// bindings
cmds.cls = @cmds.clear
cmds.dir = @cmds.ls

cmds.up = @cmds.put
cmds.upload = @cmds.up

cmds.dl = @cmds.get
cmds.download = @cmds.get

cmds.rnd = @cmds.random

cmds.addvar = @cmds.addal
cmds.addalias = @cmds.addal

cmds.delvar = @cmds.delal
cmds.delalias = @cmds.delal